# 练习 3: 更新与同步逻辑

## 学习目标

在这个练习中，你将学习：

1. 理解 Generation 和 ObservedGeneration 的作用
2. 实现 Spec 变更检测机制
3. 实现资源同步逻辑
4. 处理配置漂移问题
5. 实现定期健康检查

## 背景知识

### Generation 和 ObservedGeneration

在 Kubernetes 中，每个资源都有两个重要的版本号字段：

- **Generation**: 资源的版本号，每次 Spec（期望状态）变更时自动递增
- **ObservedGeneration**: 控制器观察并处理的版本号

**为什么需要这两个字段？**

```go
// 判断 Spec 是否发生变更
if webapp.Generation != webapp.Status.ObservedGeneration {
    // Spec 已变更，需要同步资源
    syncResources()
    // 同步完成后更新 ObservedGeneration
    webapp.Status.ObservedGeneration = webapp.Generation
}
```

**使用场景**：
- 用户修改了 WebApp 的 Replicas 从 2 改为 5
- Generation 从 1 变为 2
- 控制器检测到 Generation != ObservedGeneration
- 执行同步逻辑，更新 Deployment
- 同步完成后，设置 ObservedGeneration = 2

### 什么是配置漂移？

配置漂移（Configuration Drift）是指实际资源的配置与期望配置不一致的情况。

**产生原因**：
- 用户手动修改了 Deployment
- 其他控制器修改了资源
- 网络问题导致更新失败

**解决方案**：
- 定期检查资源配置
- 发现不一致时重新同步
- 使用 ObservedGeneration 跟踪同步状态

### 资源同步策略

**完全同步 vs 增量同步**：

```go
// 完全同步：每次都更新所有字段
deployment.Spec = buildDeploymentSpec(webapp.Spec)
client.UpdateDeployment(deployment)

// 增量同步：只更新变更的字段（推荐）
needsUpdate := false
if deployment.Spec.Replicas != webapp.Spec.Replicas {
    deployment.Spec.Replicas = webapp.Spec.Replicas
    needsUpdate = true
}
if needsUpdate {
    client.UpdateDeployment(deployment)
}
```

**增量同步的优势**：
- 减少不必要的更新
- 降低 API Server 负载
- 避免触发不必要的滚动更新

## 任务说明

在这个练习中，你需要实现 `handleRunning` 函数，处理以下场景：

### 1. 检测 Spec 变更

实现一个函数来检测 Spec 是否发生变更：

```go
func specChanged(ctx *ReconcileContext) bool {
    return ctx.WebApp.Generation != ctx.WebApp.Status.ObservedGeneration
}
```

**使用示例**：

```go
if specChanged(ctx) {
    ctx.Logger.Info("检测到 Spec 变更，开始同步")
    // 执行同步逻辑
}
```

### 2. 同步 Deployment

实现 Deployment 的同步逻辑：

```go
func syncDeployment(ctx *ReconcileContext) error {
    // 1. 获取当前的 Deployment
    deployment, err := ctx.Client.GetDeployment(ctx.WebApp.Namespace, ctx.WebApp.Name)
    if err != nil {
        return err
    }
    
    // 2. 检查哪些字段需要更新
    needsUpdate := false
    
    // 检查 Replicas
    if deployment.Spec.Replicas != ctx.WebApp.Spec.Replicas {
        ctx.Logger.Info("Replicas 变更",
            "old", deployment.Spec.Replicas,
            "new", ctx.WebApp.Spec.Replicas)
        deployment.Spec.Replicas = ctx.WebApp.Spec.Replicas
        needsUpdate = true
    }
    
    // 检查 Image
    if deployment.Spec.Image != ctx.WebApp.Spec.Image {
        ctx.Logger.Info("Image 变更",
            "old", deployment.Spec.Image,
            "new", ctx.WebApp.Spec.Image)
        deployment.Spec.Image = ctx.WebApp.Spec.Image
        needsUpdate = true
    }
    
    // 检查 Env（需要深度比较）
    if !mapsEqual(deployment.Spec.Env, ctx.WebApp.Spec.Env) {
        ctx.Logger.Info("Env 变更")
        deployment.Spec.Env = copyMap(ctx.WebApp.Spec.Env)
        needsUpdate = true
    }
    
    // 3. 如果需要更新，执行更新
    if needsUpdate {
        ctx.Logger.Info("同步 Deployment", "name", deployment.Name)
        if err := ctx.Client.UpdateDeployment(deployment); err != nil {
            return err
        }
        
        // 记录事件
        ctx.Client.RecordEvent(Event{
            Type:    EventTypeNormal,
            Reason:  "DeploymentSynced",
            Message: "Deployment 已同步到最新配置",
            Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
        })
    }
    
    return nil
}

// 辅助函数：比较两个 map 是否相等
func mapsEqual(a, b map[string]string) bool {
    if len(a) != len(b) {
        return false
    }
    for k, v := range a {
        if b[k] != v {
            return false
        }
    }
    return true
}

// 辅助函数：复制 map
func copyMap(m map[string]string) map[string]string {
    if m == nil {
        return nil
    }
    result := make(map[string]string)
    for k, v := range m {
        result[k] = v
    }
    return result
}
```

### 3. 同步 Service

实现 Service 的同步逻辑：

```go
func syncService(ctx *ReconcileContext) error {
    service, err := ctx.Client.GetService(ctx.WebApp.Namespace, ctx.WebApp.Name)
    if err != nil {
        return err
    }
    
    needsUpdate := false
    
    // 检查 Port
    if service.Spec.Port != ctx.WebApp.Spec.Port {
        ctx.Logger.Info("Service Port 变更",
            "old", service.Spec.Port,
            "new", ctx.WebApp.Spec.Port)
        service.Spec.Port = ctx.WebApp.Spec.Port
        needsUpdate = true
    }
    
    if needsUpdate {
        ctx.Logger.Info("同步 Service", "name", service.Name)
        if err := ctx.Client.UpdateService(service); err != nil {
            return err
        }
        
        ctx.Client.RecordEvent(Event{
            Type:    EventTypeNormal,
            Reason:  "ServiceSynced",
            Message: "Service 已同步到最新配置",
            Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
        })
    }
    
    return nil
}
```

### 4. 实现 handleRunning 函数

将上述逻辑组合到 `handleRunning` 函数中：

```go
func handleRunning(ctx *ReconcileContext) ReconcileResult {
    ctx.Logger.Info("处理 Running 状态", "webapp", ctx.WebApp.Name)
    
    // 步骤 1: 检查 Spec 是否变更
    if specChanged(ctx) {
        ctx.Logger.Info("检测到 Spec 变更，开始同步",
            "generation", ctx.WebApp.Generation,
            "observedGeneration", ctx.WebApp.Status.ObservedGeneration)
        
        // 步骤 2: 同步 Deployment
        if err := syncDeployment(ctx); err != nil {
            ctx.Logger.Error(err, "同步 Deployment 失败")
            return ReconcileResult{Error: err}
        }
        
        // 步骤 3: 同步 Service
        if err := syncService(ctx); err != nil {
            ctx.Logger.Error(err, "同步 Service 失败")
            return ReconcileResult{Error: err}
        }
        
        // 步骤 4: 更新 ObservedGeneration
        ctx.WebApp.Status.ObservedGeneration = ctx.WebApp.Generation
        ctx.WebApp.Status.Message = "资源已同步"
        ctx.WebApp.Status.LastReconcileTime = time.Now()
        
        if err := ctx.Client.UpdateWebAppStatus(ctx.WebApp); err != nil {
            ctx.Logger.Error(err, "更新状态失败")
            return ReconcileResult{Error: err}
        }
        
        ctx.Logger.Info("资源同步完成")
        
        // 记录事件
        ctx.Client.RecordEvent(Event{
            Type:    EventTypeNormal,
            Reason:  "ResourcesSynced",
            Message: fmt.Sprintf("资源已同步到 Generation %d", ctx.WebApp.Generation),
            Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
        })
    }
    
    // 步骤 5: 定期检查健康状态（即使没有 Spec 变更）
    // 这可以检测配置漂移和资源健康问题
    if err := verifyResourceHealth(ctx); err != nil {
        ctx.Logger.Error(err, "健康检查失败")
        // 健康检查失败不返回错误，只记录日志
        // 下次协调时会重试
    }
    
    // 步骤 6: 定期重新入队，持续监控
    return ReconcileResult{
        Requeue:      true,
        RequeueAfter: 30 * time.Second, // 30 秒后重新检查
    }
}
```

### 5. 实现健康检查（可选）

实现一个简单的健康检查函数：

```go
func verifyResourceHealth(ctx *ReconcileContext) error {
    // 检查 Deployment 健康状态
    deployment, err := ctx.Client.GetDeployment(ctx.WebApp.Namespace, ctx.WebApp.Name)
    if err != nil {
        return fmt.Errorf("获取 Deployment 失败: %w", err)
    }
    
    // 检查 ReadyReplicas
    if deployment.Status.ReadyReplicas < deployment.Spec.Replicas {
        ctx.Logger.Info("Deployment 未完全就绪",
            "ready", deployment.Status.ReadyReplicas,
            "desired", deployment.Spec.Replicas)
        // 这不是错误，只是状态信息
    }
    
    // 检查 Service 是否存在
    _, err = ctx.Client.GetService(ctx.WebApp.Namespace, ctx.WebApp.Name)
    if err != nil {
        return fmt.Errorf("获取 Service 失败: %w", err)
    }
    
    return nil
}
```

## 实现步骤

### 步骤 1: 实现 specChanged 函数

在 `reconcile.go` 中添加 Spec 变更检测逻辑。

### 步骤 2: 实现 syncDeployment 函数

添加 Deployment 同步逻辑，包括增量更新检测。

### 步骤 3: 实现 syncService 函数

添加 Service 同步逻辑。

### 步骤 4: 实现辅助函数

添加 `mapsEqual` 和 `copyMap` 等辅助函数。

### 步骤 5: 实现 handleRunning 函数

将上述函数组合到 `handleRunning` 中。

### 步骤 6: 测试

运行测试程序验证实现：

```bash
cd operator/ex3/framework
go run .
```

## 测试场景

创建一个测试程序来验证你的实现：

```go
func testExercise3() {
    fmt.Println("=== 测试练习 3: 更新与同步逻辑 ===")
    
    client := NewMockK8sClient()
    logger := &SimpleLogger{Name: "test"}
    
    // 场景 1: 创建初始资源
    webapp := &WebApp{
        Name:       "test-webapp",
        Namespace:  "default",
        Generation: 1,
        Spec: WebAppSpec{
            Image:    "nginx:1.20",
            Replicas: 2,
            Port:     80,
            Env: map[string]string{
                "ENV": "production",
            },
        },
        Status: WebAppStatus{
            Phase:              PhaseRunning,
            ObservedGeneration: 1, // 已同步
        },
        Finalizers: []string{WebAppFinalizer},
    }
    
    client.CreateWebApp(webapp)
    
    // 创建对应的 Deployment 和 Service
    deployment := &Deployment{
        Name:      "test-webapp",
        Namespace: "default",
        Spec: DeploymentSpec{
            Replicas: 2,
            Image:    "nginx:1.20",
            Env: map[string]string{
                "ENV": "production",
            },
        },
        Status: DeploymentStatus{
            ReadyReplicas: 2,
        },
    }
    client.CreateDeployment(deployment)
    
    service := &Service{
        Name:      "test-webapp",
        Namespace: "default",
        Spec: ServiceSpec{
            Port: 80,
        },
    }
    client.CreateService(service)
    
    fmt.Println("初始状态:")
    fmt.Printf("  Generation: %d\n", webapp.Generation)
    fmt.Printf("  ObservedGeneration: %d\n", webapp.Status.ObservedGeneration)
    fmt.Printf("  Deployment Replicas: %d\n", deployment.Spec.Replicas)
    fmt.Printf("  Deployment Image: %s\n", deployment.Spec.Image)
    
    // 场景 2: 修改 Spec（模拟用户更新）
    fmt.Println("\n修改 Spec:")
    webapp.Generation = 2 // Kubernetes 会自动递增
    webapp.Spec.Replicas = 5
    webapp.Spec.Image = "nginx:1.21"
    webapp.Spec.Port = 8080
    client.UpdateWebApp(webapp)
    
    fmt.Printf("  新的 Replicas: %d\n", webapp.Spec.Replicas)
    fmt.Printf("  新的 Image: %s\n", webapp.Spec.Image)
    fmt.Printf("  新的 Port: %d\n", webapp.Spec.Port)
    
    // 场景 3: 触发协调，同步资源
    fmt.Println("\n触发协调:")
    webapp, _ = client.GetWebApp("default", "test-webapp")
    ctx := NewReconcileContext(webapp, client, logger)
    result := Reconcile(ctx)
    
    fmt.Printf("  协调结果: Requeue=%v, RequeueAfter=%v\n", 
        result.Requeue, result.RequeueAfter)
    
    // 场景 4: 验证同步结果
    fmt.Println("\n同步后状态:")
    deployment, _ = client.GetDeployment("default", "test-webapp")
    service, _ = client.GetService("default", "test-webapp")
    webapp, _ = client.GetWebApp("default", "test-webapp")
    
    fmt.Printf("  ObservedGeneration: %d (应该是 2)\n", webapp.Status.ObservedGeneration)
    fmt.Printf("  Deployment Replicas: %d (应该是 5)\n", deployment.Spec.Replicas)
    fmt.Printf("  Deployment Image: %s (应该是 nginx:1.21)\n", deployment.Spec.Image)
    fmt.Printf("  Service Port: %d (应该是 8080)\n", service.Spec.Port)
    
    // 验证
    if webapp.Status.ObservedGeneration == 2 &&
       deployment.Spec.Replicas == 5 &&
       deployment.Spec.Image == "nginx:1.21" &&
       service.Spec.Port == 8080 {
        fmt.Println("\n✓ 所有资源已正确同步")
    } else {
        fmt.Println("\n✗ 资源同步失败")
    }
    
    // 场景 5: 再次协调（无变更）
    fmt.Println("\n再次协调（无 Spec 变更）:")
    webapp, _ = client.GetWebApp("default", "test-webapp")
    ctx = NewReconcileContext(webapp, client, logger)
    result = Reconcile(ctx)
    
    fmt.Printf("  应该跳过同步，只进行健康检查\n")
    fmt.Printf("  RequeueAfter: %v (定期检查)\n", result.RequeueAfter)
}
```

## 预期输出

运行测试后，你应该看到类似的输出：

```
=== 测试练习 3: 更新与同步逻辑 ===
初始状态:
  Generation: 1
  ObservedGeneration: 1
  Deployment Replicas: 2
  Deployment Image: nginx:1.20

修改 Spec:
  新的 Replicas: 5
  新的 Image: nginx:1.21
  新的 Port: 8080

触发协调:
[INFO] test: Reconcile called [webapp test-webapp phase Running]
[INFO] test: 处理 Running 状态 [webapp test-webapp]
[INFO] test: 检测到 Spec 变更，开始同步 [generation 2 observedGeneration 1]
[INFO] test: Replicas 变更 [old 2 new 5]
[INFO] test: Image 变更 [old nginx:1.20 new nginx:1.21]
[INFO] test: 同步 Deployment [name test-webapp]
[INFO] test: Service Port 变更 [old 80 new 8080]
[INFO] test: 同步 Service [name test-webapp]
[INFO] test: 资源同步完成 []
  协调结果: Requeue=true, RequeueAfter=30s

同步后状态:
  ObservedGeneration: 2 (应该是 2)
  Deployment Replicas: 5 (应该是 5)
  Deployment Image: nginx:1.21 (应该是 nginx:1.21)
  Service Port: 8080 (应该是 8080)

✓ 所有资源已正确同步

再次协调（无 Spec 变更）:
[INFO] test: Reconcile called [webapp test-webapp phase Running]
[INFO] test: 处理 Running 状态 [webapp test-webapp]
  应该跳过同步，只进行健康检查
  RequeueAfter: 30s
```

## 验证清单

完成练习后，确保：

- [ ] `specChanged` 函数能够正确检测 Spec 变更
- [ ] `syncDeployment` 函数能够同步 Deployment 配置
- [ ] `syncService` 函数能够同步 Service 配置
- [ ] 增量更新：只更新变更的字段
- [ ] ObservedGeneration 正确更新
- [ ] 无变更时跳过同步逻辑
- [ ] 定期重新入队进行健康检查
- [ ] 事件被正确记录

## 关键要点

1. **Generation 跟踪**: 使用 Generation 和 ObservedGeneration 检测 Spec 变更
2. **增量同步**: 只更新变更的字段，避免不必要的更新
3. **深度比较**: 对于复杂类型（如 map），需要深度比较
4. **幂等性**: 同步逻辑应该是幂等的，多次执行结果相同
5. **定期检查**: 即使没有变更，也要定期检查健康状态
6. **配置漂移**: 定期同步可以检测和修复配置漂移

## 常见问题

### Q: 为什么需要 ObservedGeneration？

A: ObservedGeneration 记录控制器已经处理的版本，用于判断是否有新的变更需要处理。如果 Generation > ObservedGeneration，说明有新的变更。

### Q: 为什么要使用增量同步而不是完全同步？

A: 增量同步只更新变更的字段，可以：
- 减少 API Server 负载
- 避免触发不必要的滚动更新
- 提高性能

### Q: 为什么要定期重新入队？

A: 定期重新入队可以：
- 检测配置漂移
- 监控资源健康状态
- 处理临时性错误的自动恢复

### Q: 如何处理 map 类型的比较？

A: 需要实现深度比较函数，逐个比较 key 和 value。简单的 `==` 比较对 map 无效。

## 参考答案

如果你完成了实现或遇到困难，可以查看参考答案：

```bash
cd operator/ex3/solutions/ex3
go run .        # 运行参考实现
go test -v      # 运行测试
```

参考答案位于 `solutions/ex3/` 目录。

## 下一步

完成这个练习后，继续 [练习 4: 删除与 Finalizer](./4.md)，学习如何实现完整的资源删除流程。
