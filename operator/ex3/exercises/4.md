# 练习 4: 删除与 Finalizer

## 学习目标

在这个练习中，你将学习：

1. 理解 Finalizer 的完整工作机制
2. 实现优雅删除流程
3. 确保资源清理顺序正确
4. 处理删除过程中的错误
5. 理解 DeletionTimestamp 的作用

## 背景知识

### Finalizer 机制详解

Finalizer 是 Kubernetes 的一种机制，用于在资源被删除前执行清理操作。

**工作流程**：

```
1. 用户执行 kubectl delete webapp my-app
   ↓
2. Kubernetes 设置 DeletionTimestamp
   ↓
3. 资源不会立即删除，等待 Finalizer 被移除
   ↓
4. Operator 检测到 DeletionTimestamp != nil
   ↓
5. Operator 执行清理逻辑（删除依赖资源）
   ↓
6. Operator 移除 Finalizer
   ↓
7. Kubernetes 最终删除资源
```

**关键字段**：

```go
type WebApp struct {
    DeletionTimestamp *time.Time // nil 表示未删除，非 nil 表示正在删除
    Finalizers        []string    // Finalizer 列表
    // ...
}
```

### 为什么需要 Finalizer？

**场景 1: 级联删除**
- WebApp 被删除时，需要先删除 Deployment 和 Service
- 如果没有 Finalizer，WebApp 会立即删除
- Deployment 和 Service 会变成孤儿资源

**场景 2: 外部资源清理**
- 如果 Operator 创建了外部资源（如云服务商的负载均衡器）
- 需要在删除前清理这些外部资源
- Finalizer 确保清理完成后才删除 Kubernetes 资源

**场景 3: 数据备份**
- 删除前可能需要备份数据
- Finalizer 提供了执行备份的机会

### 删除顺序的重要性

正确的删除顺序可以避免问题：

```
1. Service（停止接收新流量）
   ↓
2. Deployment（停止 Pod）
   ↓
3. 其他依赖资源
   ↓
4. 移除 Finalizer
```

**为什么这个顺序重要？**
- 先删除 Service 可以停止新流量进入
- 再删除 Deployment 可以优雅地停止 Pod
- 最后移除 Finalizer 让 Kubernetes 删除主资源

### DeletionTimestamp 的作用

```go
// 检查资源是否正在被删除
if webapp.DeletionTimestamp != nil {
    // 资源正在被删除，执行清理逻辑
    handleDeletion(ctx)
} else {
    // 资源正常运行，执行正常逻辑
    handleNormalReconciliation(ctx)
}
```

**注意事项**：
- DeletionTimestamp 一旦设置就不会被清除
- 只有移除所有 Finalizer 后，资源才会被真正删除
- 删除过程中，资源仍然可以被读取和更新（Status）

## 任务说明

在这个练习中，你需要实现 `handleDeletion` 函数，完成以下任务：

### 1. 检测删除请求

在 `Reconcile` 函数中检测删除：

```go
func Reconcile(ctx *ReconcileContext) ReconcileResult {
    ctx.Logger.Info("Reconcile called", "webapp", ctx.WebApp.Name, "phase", ctx.WebApp.Status.Phase)
    
    // 1. 检查是否正在删除
    if ctx.WebApp.DeletionTimestamp != nil {
        return handleDeletion(ctx)
    }
    
    // 2. 正常的状态机逻辑
    switch ctx.WebApp.Status.Phase {
    // ...
    }
}
```

### 2. 实现 handleDeletion 函数

实现完整的删除流程：

```go
func handleDeletion(ctx *ReconcileContext) ReconcileResult {
    ctx.Logger.Info("处理删除", "webapp", ctx.WebApp.Name)
    
    // 步骤 1: 检查是否有 Finalizer
    if !hasFinalizer(ctx.WebApp, WebAppFinalizer) {
        // 没有 Finalizer，直接返回
        // Kubernetes 会自动删除资源
        ctx.Logger.Info("没有 Finalizer，跳过清理")
        return ReconcileResult{}
    }
    
    // 步骤 2: 转换到 Deleting 状态（如果还没有）
    if ctx.WebApp.Status.Phase != PhaseDeleting {
        ctx.WebApp.Status.Phase = PhaseDeleting
        ctx.WebApp.Status.Message = "正在删除资源"
        ctx.WebApp.Status.LastReconcileTime = time.Now()
        
        if err := ctx.Client.UpdateWebAppStatus(ctx.WebApp); err != nil {
            ctx.Logger.Error(err, "更新状态失败")
            return ReconcileResult{Error: err}
        }
        
        ctx.Logger.Info("状态已转换到 Deleting")
        
        // 记录事件
        ctx.Client.RecordEvent(Event{
            Type:    EventTypeNormal,
            Reason:  "DeletionStarted",
            Message: "开始删除资源",
            Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
        })
    }
    
    // 步骤 3: 删除 Service（先停止流量）
    if err := deleteService(ctx); err != nil {
        ctx.Logger.Error(err, "删除 Service 失败")
        return ReconcileResult{Error: err}
    }
    
    // 步骤 4: 删除 Deployment（再停止 Pod）
    if err := deleteDeployment(ctx); err != nil {
        ctx.Logger.Error(err, "删除 Deployment 失败")
        return ReconcileResult{Error: err}
    }
    
    // 步骤 5: 等待资源清理完成（可选）
    // 在真实场景中，可能需要等待 Pod 完全停止
    if err := waitForCleanup(ctx); err != nil {
        ctx.Logger.Error(err, "等待清理完成失败")
        return ReconcileResult{
            Requeue:      true,
            RequeueAfter: 5 * time.Second,
        }
    }
    
    // 步骤 6: 移除 Finalizer
    removeFinalizer(ctx.WebApp, WebAppFinalizer)
    if err := ctx.Client.UpdateWebApp(ctx.WebApp); err != nil {
        ctx.Logger.Error(err, "移除 Finalizer 失败")
        return ReconcileResult{Error: err}
    }
    
    ctx.Logger.Info("Finalizer 已移除，资源将被删除")
    
    // 记录事件
    ctx.Client.RecordEvent(Event{
        Type:    EventTypeNormal,
        Reason:  "FinalizerRemoved",
        Message: "Finalizer 已移除，资源清理完成",
        Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
    })
    
    // 不需要重新入队，资源即将被删除
    return ReconcileResult{}
}
```

### 3. 实现 deleteService 函数

实现 Service 删除逻辑：

```go
func deleteService(ctx *ReconcileContext) error {
    serviceName := ctx.WebApp.Name
    
    // 1. 检查 Service 是否存在
    _, err := ctx.Client.GetService(ctx.WebApp.Namespace, serviceName)
    if err != nil {
        // Service 不存在，可能已经被删除
        ctx.Logger.Info("Service 不存在，跳过删除", "name", serviceName)
        return nil
    }
    
    // 2. 删除 Service
    ctx.Logger.Info("删除 Service", "name", serviceName)
    if err := ctx.Client.DeleteService(ctx.WebApp.Namespace, serviceName); err != nil {
        return fmt.Errorf("删除 Service 失败: %w", err)
    }
    
    ctx.Logger.Info("Service 已删除", "name", serviceName)
    
    // 3. 记录事件
    ctx.Client.RecordEvent(Event{
        Type:    EventTypeNormal,
        Reason:  "ServiceDeleted",
        Message: fmt.Sprintf("Service %s 已删除", serviceName),
        Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
    })
    
    return nil
}
```

### 4. 实现 deleteDeployment 函数

实现 Deployment 删除逻辑：

```go
func deleteDeployment(ctx *ReconcileContext) error {
    deploymentName := ctx.WebApp.Name
    
    // 1. 检查 Deployment 是否存在
    _, err := ctx.Client.GetDeployment(ctx.WebApp.Namespace, deploymentName)
    if err != nil {
        // Deployment 不存在，可能已经被删除
        ctx.Logger.Info("Deployment 不存在，跳过删除", "name", deploymentName)
        return nil
    }
    
    // 2. 删除 Deployment
    ctx.Logger.Info("删除 Deployment", "name", deploymentName)
    if err := ctx.Client.DeleteDeployment(ctx.WebApp.Namespace, deploymentName); err != nil {
        return fmt.Errorf("删除 Deployment 失败: %w", err)
    }
    
    ctx.Logger.Info("Deployment 已删除", "name", deploymentName)
    
    // 3. 记录事件
    ctx.Client.RecordEvent(Event{
        Type:    EventTypeNormal,
        Reason:  "DeploymentDeleted",
        Message: fmt.Sprintf("Deployment %s 已删除", deploymentName),
        Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
    })
    
    return nil
}
```

### 5. 实现 waitForCleanup 函数（可选）

在真实场景中，可能需要等待资源完全清理：

```go
func waitForCleanup(ctx *ReconcileContext) error {
    // 在模拟环境中，资源立即删除
    // 在真实 Kubernetes 中，可能需要等待 Pod 终止
    
    // 检查 Deployment 是否还存在
    _, err := ctx.Client.GetDeployment(ctx.WebApp.Namespace, ctx.WebApp.Name)
    if err == nil {
        // Deployment 还存在，需要等待
        ctx.Logger.Info("等待 Deployment 清理完成")
        return fmt.Errorf("deployment still exists")
    }
    
    // 检查 Service 是否还存在
    _, err = ctx.Client.GetService(ctx.WebApp.Namespace, ctx.WebApp.Name)
    if err == nil {
        // Service 还存在，需要等待
        ctx.Logger.Info("等待 Service 清理完成")
        return fmt.Errorf("service still exists")
    }
    
    ctx.Logger.Info("所有资源已清理完成")
    return nil
}
```

## 实现步骤

### 步骤 1: 修改 Reconcile 函数

在 `Reconcile` 函数开头添加删除检测：

```go
if ctx.WebApp.DeletionTimestamp != nil {
    return handleDeletion(ctx)
}
```

### 步骤 2: 实现 deleteService 函数

添加 Service 删除逻辑。

### 步骤 3: 实现 deleteDeployment 函数

添加 Deployment 删除逻辑。

### 步骤 4: 实现 waitForCleanup 函数

添加清理等待逻辑（可选）。

### 步骤 5: 实现 handleDeletion 函数

将上述函数组合到 `handleDeletion` 中。

### 步骤 6: 测试

运行测试程序验证实现：

```bash
cd operator/ex3/framework
go run .
```

## 测试场景

创建一个测试程序来验证你的实现：

```go
func testExercise4() {
    fmt.Println("=== 测试练习 4: 删除与 Finalizer ===")
    
    client := NewMockK8sClient()
    logger := &SimpleLogger{Name: "test"}
    
    // 场景 1: 创建完整的资源
    webapp := &WebApp{
        Name:       "test-webapp",
        Namespace:  "default",
        Generation: 1,
        Spec: WebAppSpec{
            Image:    "nginx:latest",
            Replicas: 2,
            Port:     80,
        },
        Status: WebAppStatus{
            Phase:              PhaseRunning,
            ObservedGeneration: 1,
        },
        Finalizers: []string{WebAppFinalizer},
    }
    
    client.CreateWebApp(webapp)
    
    // 创建依赖资源
    deployment := &Deployment{
        Name:      "test-webapp",
        Namespace: "default",
        Spec: DeploymentSpec{
            Replicas: 2,
            Image:    "nginx:latest",
        },
        Status: DeploymentStatus{
            ReadyReplicas: 2,
        },
        OwnerReferences: []OwnerReference{
            {
                Name: "test-webapp",
                UID:  "default-test-webapp",
            },
        },
    }
    client.CreateDeployment(deployment)
    
    service := &Service{
        Name:      "test-webapp",
        Namespace: "default",
        Spec: ServiceSpec{
            Port: 80,
        },
        OwnerReferences: []OwnerReference{
            {
                Name: "test-webapp",
                UID:  "default-test-webapp",
            },
        },
    }
    client.CreateService(service)
    
    fmt.Println("初始状态:")
    fmt.Printf("  WebApp Phase: %s\n", webapp.Status.Phase)
    fmt.Printf("  Finalizers: %v\n", webapp.Finalizers)
    fmt.Printf("  Deployment 存在: true\n")
    fmt.Printf("  Service 存在: true\n")
    
    // 场景 2: 设置删除时间戳（模拟 kubectl delete）
    fmt.Println("\n模拟删除请求:")
    now := time.Now()
    webapp.DeletionTimestamp = &now
    client.UpdateWebApp(webapp)
    
    fmt.Printf("  DeletionTimestamp: %v\n", webapp.DeletionTimestamp)
    
    // 场景 3: 触发协调，执行删除流程
    fmt.Println("\n触发协调:")
    webapp, _ = client.GetWebApp("default", "test-webapp")
    ctx := NewReconcileContext(webapp, client, logger)
    result := Reconcile(ctx)
    
    fmt.Printf("  协调结果: Requeue=%v, Error=%v\n", result.Requeue, result.Error)
    
    // 场景 4: 验证删除结果
    fmt.Println("\n删除后状态:")
    
    // 检查 WebApp 状态
    webapp, _ = client.GetWebApp("default", "test-webapp")
    fmt.Printf("  WebApp Phase: %s\n", webapp.Status.Phase)
    fmt.Printf("  Finalizers: %v\n", webapp.Finalizers)
    
    // 检查 Deployment 是否被删除
    _, deploymentErr := client.GetDeployment("default", "test-webapp")
    fmt.Printf("  Deployment 已删除: %v\n", deploymentErr != nil)
    
    // 检查 Service 是否被删除
    _, serviceErr := client.GetService("default", "test-webapp")
    fmt.Printf("  Service 已删除: %v\n", serviceErr != nil)
    
    // 验证
    if len(webapp.Finalizers) == 0 &&
       deploymentErr != nil &&
       serviceErr != nil {
        fmt.Println("\n✓ 删除流程正确执行")
        fmt.Println("  - Service 已删除")
        fmt.Println("  - Deployment 已删除")
        fmt.Println("  - Finalizer 已移除")
        fmt.Println("  - WebApp 将被 Kubernetes 删除")
    } else {
        fmt.Println("\n✗ 删除流程失败")
    }
    
    // 显示事件
    events := client.GetEvents()
    fmt.Printf("\n记录的事件 (%d 个):\n", len(events))
    for i, event := range events {
        if event.Reason == "DeletionStarted" ||
           event.Reason == "ServiceDeleted" ||
           event.Reason == "DeploymentDeleted" ||
           event.Reason == "FinalizerRemoved" {
            fmt.Printf("  %d. [%s] %s: %s\n", i+1, event.Type, event.Reason, event.Message)
        }
    }
}
```

## 预期输出

运行测试后，你应该看到类似的输出：

```
=== 测试练习 4: 删除与 Finalizer ===
初始状态:
  WebApp Phase: Running
  Finalizers: [webapp.example.com/finalizer]
  Deployment 存在: true
  Service 存在: true

模拟删除请求:
  DeletionTimestamp: 2024-01-15 10:30:00 +0000 UTC

触发协调:
[INFO] test: Reconcile called [webapp test-webapp phase Running]
[INFO] test: 处理删除 [webapp test-webapp]
[INFO] test: 状态已转换到 Deleting []
[INFO] test: 删除 Service [name test-webapp]
[INFO] test: Service 已删除 [name test-webapp]
[INFO] test: 删除 Deployment [name test-webapp]
[INFO] test: Deployment 已删除 [name test-webapp]
[INFO] test: 所有资源已清理完成 []
[INFO] test: Finalizer 已移除，资源将被删除 []
  协调结果: Requeue=false, Error=<nil>

删除后状态:
  WebApp Phase: Deleting
  Finalizers: []
  Deployment 已删除: true
  Service 已删除: true

✓ 删除流程正确执行
  - Service 已删除
  - Deployment 已删除
  - Finalizer 已移除
  - WebApp 将被 Kubernetes 删除

记录的事件 (4 个):
  1. [Normal] DeletionStarted: 开始删除资源
  2. [Normal] ServiceDeleted: Service test-webapp 已删除
  3. [Normal] DeploymentDeleted: Deployment test-webapp 已删除
  4. [Normal] FinalizerRemoved: Finalizer 已移除，资源清理完成
```

## 验证清单

完成练习后，确保：

- [ ] 检测到 DeletionTimestamp 时进入删除流程
- [ ] 状态正确转换到 Deleting
- [ ] Service 被正确删除
- [ ] Deployment 被正确删除
- [ ] 删除顺序正确（Service → Deployment）
- [ ] Finalizer 被正确移除
- [ ] 删除过程中的错误被正确处理
- [ ] 事件被正确记录
- [ ] 幂等性：重复调用不会出错

## 关键要点

1. **DeletionTimestamp**: 检测资源是否正在被删除的关键字段
2. **Finalizer**: 确保清理逻辑执行完成后才删除资源
3. **删除顺序**: 先删除 Service（停止流量），再删除 Deployment（停止 Pod）
4. **幂等性**: 删除逻辑应该是幂等的，资源不存在时不报错
5. **错误处理**: 删除失败时应该重试，不要移除 Finalizer
6. **状态转换**: 转换到 Deleting 状态，让用户知道资源正在删除

## 常见问题

### Q: 为什么要在删除前转换到 Deleting 状态？

A: 转换到 Deleting 状态可以：
- 让用户知道资源正在删除
- 防止其他协调逻辑执行
- 提供清晰的状态追踪

### Q: 如果删除 Service 失败怎么办？

A: 返回错误，不移除 Finalizer。协调循环会自动重试，直到成功。

### Q: 为什么要先删除 Service 再删除 Deployment？

A: 先删除 Service 可以停止新流量进入，然后再优雅地停止 Pod。这样可以减少服务中断。

### Q: 如果 Finalizer 移除失败怎么办？

A: 返回错误，协调循环会重试。资源会一直保持删除中状态，直到 Finalizer 成功移除。

### Q: 可以有多个 Finalizer 吗？

A: 可以。每个控制器可以添加自己的 Finalizer。只有所有 Finalizer 都被移除后，资源才会被删除。

## 参考答案

如果你完成了实现或遇到困难，可以查看参考答案：

```bash
cd operator/ex3/solutions/ex4
go run .        # 运行参考实现
go test -v      # 运行测试
```

参考答案位于 `solutions/ex4/` 目录。

## 下一步

完成这个练习后，继续 [练习 5: 错误处理与可观测性](./5.md)，学习如何增强系统的健壮性和可观测性。
