# 练习 2: 资源创建与管理

## 学习目标

在这个练习中，你将学习：

1. 创建和管理 Kubernetes Deployment 资源
2. 创建和管理 Kubernetes Service 资源
3. 理解和使用 OwnerReference 机制
4. 实现资源的幂等性创建
5. 检查资源的就绪状态

## 背景知识

### 什么是 OwnerReference？

OwnerReference 是 Kubernetes 中的一种机制，用于建立资源之间的所有权关系。当一个资源（Owner）被删除时，Kubernetes 会自动删除所有由它拥有的资源（Owned）。

```go
type OwnerReference struct {
    Name string // 所有者名称
    UID  string // 所有者 UID
}
```

**为什么需要 OwnerReference？**

- **级联删除**: 删除 WebApp 时自动删除 Deployment 和 Service
- **关系追踪**: 清晰地表达资源之间的依赖关系
- **垃圾回收**: Kubernetes 自动清理孤儿资源

### 什么是幂等性？

幂等性是指同一个操作执行多次和执行一次的效果相同。在 Operator 中，这意味着：

- 如果资源已存在，不要重复创建
- 如果资源配置正确，不要重复更新
- 协调循环可以安全地多次执行

**实现幂等性的模式**：

```go
// 1. 检查资源是否存在
deployment, err := client.GetDeployment(namespace, name)
if err != nil {
    // 2. 不存在则创建
    return client.CreateDeployment(deployment)
}
// 3. 已存在则跳过或更新
return nil
```

### 资源就绪性检查

创建资源后，需要等待资源就绪才能转换到下一个状态：

- **Deployment 就绪**: `ReadyReplicas == Replicas`
- **Service 就绪**: Service 已创建（Service 通常立即就绪）

## 任务说明

在这个练习中，你需要实现 `handleCreating` 函数，完成以下任务：

### 1. 创建 Deployment

实现创建 Deployment 的逻辑：

```go
func ensureDeployment(ctx *ReconcileContext) error {
    deploymentName := ctx.WebApp.Name
    
    // 1. 检查 Deployment 是否已存在
    _, err := ctx.Client.GetDeployment(ctx.WebApp.Namespace, deploymentName)
    if err == nil {
        // 已存在，跳过
        ctx.Logger.Info("Deployment 已存在", "name", deploymentName)
        return nil
    }
    
    // 2. 构建 Deployment 对象
    deployment := &Deployment{
        Name:      deploymentName,
        Namespace: ctx.WebApp.Namespace,
        Spec: DeploymentSpec{
            Replicas: ctx.WebApp.Spec.Replicas,
            Image:    ctx.WebApp.Spec.Image,
            Env:      ctx.WebApp.Spec.Env,
        },
        OwnerReferences: []OwnerReference{
            {
                Name: ctx.WebApp.Name,
                UID:  fmt.Sprintf("%s-%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
            },
        },
    }
    
    // 3. 创建 Deployment
    if err := ctx.Client.CreateDeployment(deployment); err != nil {
        ctx.Logger.Error(err, "创建 Deployment 失败")
        return err
    }
    
    ctx.Logger.Info("Deployment 已创建", "name", deploymentName)
    
    // 4. 记录事件
    ctx.Client.RecordEvent(Event{
        Type:    EventTypeNormal,
        Reason:  "DeploymentCreated",
        Message: fmt.Sprintf("Deployment %s 已创建", deploymentName),
        Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
    })
    
    return nil
}
```

### 2. 创建 Service

实现创建 Service 的逻辑：

```go
func ensureService(ctx *ReconcileContext) error {
    serviceName := ctx.WebApp.Name
    
    // 1. 检查 Service 是否已存在
    _, err := ctx.Client.GetService(ctx.WebApp.Namespace, serviceName)
    if err == nil {
        ctx.Logger.Info("Service 已存在", "name", serviceName)
        return nil
    }
    
    // 2. 构建 Service 对象
    service := &Service{
        Name:      serviceName,
        Namespace: ctx.WebApp.Namespace,
        Spec: ServiceSpec{
            Port: ctx.WebApp.Spec.Port,
            Selector: map[string]string{
                "app": ctx.WebApp.Name,
            },
        },
        OwnerReferences: []OwnerReference{
            {
                Name: ctx.WebApp.Name,
                UID:  fmt.Sprintf("%s-%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
            },
        },
    }
    
    // 3. 创建 Service
    if err := ctx.Client.CreateService(service); err != nil {
        ctx.Logger.Error(err, "创建 Service 失败")
        return err
    }
    
    ctx.Logger.Info("Service 已创建", "name", serviceName)
    
    // 记录事件
    ctx.Client.RecordEvent(Event{
        Type:    EventTypeNormal,
        Reason:  "ServiceCreated",
        Message: fmt.Sprintf("Service %s 已创建", serviceName),
        Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
    })
    
    return nil
}
```

### 3. 检查资源就绪性

实现检查资源是否就绪的逻辑：

```go
func checkResourcesReady(ctx *ReconcileContext) (bool, error) {
    // 1. 检查 Deployment 就绪
    deployment, err := ctx.Client.GetDeployment(ctx.WebApp.Namespace, ctx.WebApp.Name)
    if err != nil {
        return false, err
    }
    
    if deployment.Status.ReadyReplicas < deployment.Spec.Replicas {
        ctx.Logger.Info("Deployment 未就绪",
            "ready", deployment.Status.ReadyReplicas,
            "desired", deployment.Spec.Replicas)
        return false, nil
    }
    
    // 2. 检查 Service 存在
    _, err = ctx.Client.GetService(ctx.WebApp.Namespace, ctx.WebApp.Name)
    if err != nil {
        return false, err
    }
    
    ctx.Logger.Info("所有资源已就绪")
    return true, nil
}
```

### 4. 实现 handleCreating 函数

将上述逻辑组合到 `handleCreating` 函数中：

```go
func handleCreating(ctx *ReconcileContext) ReconcileResult {
    ctx.Logger.Info("处理 Creating 状态", "webapp", ctx.WebApp.Name)
    
    // 步骤 1: 创建 Deployment
    if err := ensureDeployment(ctx); err != nil {
        ctx.Logger.Error(err, "确保 Deployment 失败")
        return ReconcileResult{Error: err}
    }
    
    // 步骤 2: 创建 Service
    if err := ensureService(ctx); err != nil {
        ctx.Logger.Error(err, "确保 Service 失败")
        return ReconcileResult{Error: err}
    }
    
    // 步骤 3: 检查资源就绪性
    ready, err := checkResourcesReady(ctx)
    if err != nil {
        ctx.Logger.Error(err, "检查资源就绪性失败")
        return ReconcileResult{Error: err}
    }
    
    if !ready {
        // 资源未就绪，5 秒后重试
        ctx.Logger.Info("资源未就绪，等待中...")
        return ReconcileResult{
            Requeue:      true,
            RequeueAfter: 5 * time.Second,
        }
    }
    
    // 步骤 4: 所有资源就绪，转换到 Running 状态
    ctx.WebApp.Status.Phase = PhaseRunning
    ctx.WebApp.Status.Message = "所有资源已就绪"
    ctx.WebApp.Status.LastReconcileTime = time.Now()
    ctx.WebApp.Status.ObservedGeneration = ctx.WebApp.Generation
    
    if err := ctx.Client.UpdateWebAppStatus(ctx.WebApp); err != nil {
        ctx.Logger.Error(err, "更新状态失败")
        return ReconcileResult{Error: err}
    }
    
    ctx.Logger.Info("状态已转换", "from", PhaseCreating, "to", PhaseRunning)
    
    // 记录事件
    ctx.Client.RecordEvent(Event{
        Type:    EventTypeNormal,
        Reason:  "StateTransition",
        Message: fmt.Sprintf("状态从 %s 转换到 %s", PhaseCreating, PhaseRunning),
        Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
    })
    
    // 立即重新入队以处理 Running 状态
    return ReconcileResult{Requeue: true}
}
```

## 实现步骤

### 步骤 1: 实现 ensureDeployment 函数

在 `reconcile.go` 中添加创建 Deployment 的逻辑。

### 步骤 2: 实现 ensureService 函数

添加创建 Service 的逻辑。

### 步骤 3: 实现 checkResourcesReady 函数

添加检查资源就绪性的逻辑。

### 步骤 4: 实现 handleCreating 函数

将上述函数组合到 `handleCreating` 中。

### 步骤 5: 测试

运行测试程序验证实现：

```bash
cd operator/ex3/framework
go run .
```

## 测试场景

创建一个测试程序来验证你的实现：

```go
func testExercise2() {
    fmt.Println("=== 测试练习 2: 资源创建与管理 ===")
    
    client := NewMockK8sClient()
    logger := &SimpleLogger{Name: "test"}
    
    // 场景 1: 创建 WebApp 并协调到 Creating 状态
    webapp := &WebApp{
        Name:       "test-webapp",
        Namespace:  "default",
        Generation: 1,
        Spec: WebAppSpec{
            Image:    "nginx:latest",
            Replicas: 2,
            Port:     80,
        },
        Status: WebAppStatus{
            Phase: PhaseCreating,
        },
        Finalizers: []string{WebAppFinalizer},
    }
    
    client.CreateWebApp(webapp)
    
    // 第一次协调：创建资源
    webapp, _ = client.GetWebApp("default", "test-webapp")
    ctx := NewReconcileContext(webapp, client, logger)
    result := Reconcile(ctx)
    
    fmt.Printf("第一次协调结果: Requeue=%v, RequeueAfter=%v\n", 
        result.Requeue, result.RequeueAfter)
    
    // 验证 Deployment 已创建
    deployment, err := client.GetDeployment("default", "test-webapp")
    if err != nil {
        fmt.Printf("❌ Deployment 未创建: %v\n", err)
    } else {
        fmt.Printf("✓ Deployment 已创建: %s\n", deployment.Name)
        fmt.Printf("  Replicas: %d\n", deployment.Spec.Replicas)
        fmt.Printf("  Image: %s\n", deployment.Spec.Image)
        fmt.Printf("  OwnerReferences: %v\n", deployment.OwnerReferences)
    }
    
    // 验证 Service 已创建
    service, err := client.GetService("default", "test-webapp")
    if err != nil {
        fmt.Printf("❌ Service 未创建: %v\n", err)
    } else {
        fmt.Printf("✓ Service 已创建: %s\n", service.Name)
        fmt.Printf("  Port: %d\n", service.Spec.Port)
        fmt.Printf("  OwnerReferences: %v\n", service.OwnerReferences)
    }
    
    // 场景 2: 模拟 Deployment 就绪
    deployment.Status.ReadyReplicas = deployment.Spec.Replicas
    client.UpdateDeployment(deployment)
    
    // 第二次协调：检查就绪性
    webapp, _ = client.GetWebApp("default", "test-webapp")
    ctx = NewReconcileContext(webapp, client, logger)
    result = Reconcile(ctx)
    
    fmt.Printf("\n第二次协调结果: Requeue=%v\n", result.Requeue)
    
    // 验证状态转换
    webapp, _ = client.GetWebApp("default", "test-webapp")
    fmt.Printf("当前状态: %s\n", webapp.Status.Phase)
    fmt.Printf("ObservedGeneration: %d\n", webapp.Status.ObservedGeneration)
}
```

## 预期输出

运行测试后，你应该看到类似的输出：

```
=== 测试练习 2: 资源创建与管理 ===
[INFO] test: 处理 Creating 状态 [webapp test-webapp]
[INFO] test: Deployment 已创建 [name test-webapp]
[INFO] test: Service 已创建 [name test-webapp]
[INFO] test: Deployment 未就绪 [ready 0 desired 2]
第一次协调结果: Requeue=true, RequeueAfter=5s
✓ Deployment 已创建: test-webapp
  Replicas: 2
  Image: nginx:latest
  OwnerReferences: [{test-webapp default-test-webapp}]
✓ Service 已创建: test-webapp
  Port: 80
  OwnerReferences: [{test-webapp default-test-webapp}]

[INFO] test: 处理 Creating 状态 [webapp test-webapp]
[INFO] test: Deployment 已存在 [name test-webapp]
[INFO] test: Service 已存在 [name test-webapp]
[INFO] test: 所有资源已就绪 []
[INFO] test: 状态已转换 [from Creating to Running]
第二次协调结果: Requeue=true
当前状态: Running
ObservedGeneration: 1
```

## 验证清单

完成练习后，确保：

- [ ] `ensureDeployment` 函数能够创建 Deployment
- [ ] `ensureService` 函数能够创建 Service
- [ ] OwnerReference 正确设置
- [ ] 幂等性：重复调用不会重复创建
- [ ] `checkResourcesReady` 能够正确检查就绪性
- [ ] 资源未就绪时返回 RequeueAfter
- [ ] 资源就绪后转换到 Running 状态
- [ ] 事件被正确记录

## 关键要点

1. **OwnerReference**: 建立资源所有权关系，实现级联删除
2. **幂等性**: 检查资源是否存在，避免重复创建
3. **就绪性检查**: 等待资源就绪后再转换状态
4. **重试机制**: 使用 RequeueAfter 实现定时重试
5. **事件记录**: 记录关键操作，便于调试和监控

## 常见问题

### Q: 为什么需要 OwnerReference？

A: OwnerReference 确保当 WebApp 被删除时，Deployment 和 Service 也会被自动删除，避免资源泄漏。

### Q: 如何实现幂等性？

A: 在创建资源前先检查是否已存在，如果存在则跳过创建。

### Q: 为什么要等待资源就绪？

A: 确保 Deployment 的 Pod 已经启动并就绪，才能认为应用真正可用。

### Q: RequeueAfter 的作用是什么？

A: 告诉控制器在指定时间后重新处理这个资源，用于实现定时检查。

## 参考答案

如果你完成了实现或遇到困难，可以查看参考答案：

```bash
cd operator/ex3/solutions/ex2
go run .        # 运行参考实现
go test -v      # 运行测试
```

## 下一步

完成这个练习后，继续 [练习 3: 更新与同步逻辑](./3.md)，学习如何处理 Spec 变更和资源同步。
