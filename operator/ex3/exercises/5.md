# 练习 5: 错误处理与可观测性

## 学习目标

在这个练习中，你将学习：

1. 实现错误分类（临时性 vs 永久性）
2. 实现智能重试策略
3. 增强 Status Conditions 管理
4. 实现 Panic 恢复机制
5. 提升系统可观测性
6. 实现从 Failed 状态恢复

## 背景知识

### 错误分类

在 Kubernetes Operator 中，正确分类错误非常重要：

**临时性错误（Retryable Error）**：
- 网络超时
- 资源暂时不可用
- API Server 限流
- 应该自动重试

**永久性错误（Permanent Error）**：
- 配置错误（如无效的镜像名）
- 权限不足
- 资源配额超限
- 不应该无限重试，需要人工介入

**错误类型定义**：

```go
// RetryableError 可重试错误（临时性错误）
type RetryableError struct {
    Reason string        // 错误原因
    After  time.Duration // 建议重试间隔
}

func (e *RetryableError) Error() string {
    return fmt.Sprintf("retryable error: %s (retry after %v)", e.Reason, e.After)
}

// PermanentError 永久性错误
type PermanentError struct {
    Reason string // 错误原因
}

func (e *PermanentError) Error() string {
    return fmt.Sprintf("permanent error: %s", e.Reason)
}
```

### Status Conditions

Conditions 提供资源状态的详细信息，是 Kubernetes 的标准做法：

```go
type Condition struct {
    Type               string    // 条件类型，如 "Ready", "Progressing"
    Status             string    // 条件状态: "True", "False", "Unknown"
    LastTransitionTime time.Time // 最后转换时间
    Reason             string    // 原因（机器可读）
    Message            string    // 详细消息（人类可读）
}
```

**常见的 Condition 类型**：
- **Ready**: 资源是否就绪
- **Progressing**: 资源是否正在处理中
- **Degraded**: 资源是否处于降级状态
- **Available**: 资源是否可用

**Condition 状态**：
- **True**: 条件满足
- **False**: 条件不满足
- **Unknown**: 状态未知

### Panic 恢复

在生产环境中，Panic 可能导致整个控制器崩溃。需要实现 Panic 恢复机制：

```go
defer func() {
    if r := recover(); r != nil {
        // 捕获 panic
        // 记录日志
        // 转换为错误
    }
}()
```

### 重试策略

**指数退避（Exponential Backoff）**：

```
第 1 次重试: 1 秒后
第 2 次重试: 2 秒后
第 3 次重试: 4 秒后
第 4 次重试: 8 秒后
...
最大间隔: 5 分钟
```

**使用 RequeueAfter**：

```go
return ReconcileResult{
    Requeue:      true,
    RequeueAfter: 10 * time.Second, // 10 秒后重试
}
```

## 任务说明

在这个练习中，你需要增强整个协调循环的错误处理和可观测性：

### 1. 增强 Reconcile 函数

添加 Panic 恢复和 Conditions 管理：

```go
func Reconcile(ctx *ReconcileContext) ReconcileResult {
    // Panic 恢复
    defer func() {
        if r := recover(); r != nil {
            ctx.Logger.Error(fmt.Errorf("%v", r), "Panic 恢复")
            
            // 转换到 Failed 状态
            ctx.WebApp.Status.Phase = PhaseFailed
            ctx.WebApp.Status.Message = fmt.Sprintf("Panic: %v", r)
            ctx.WebApp.Status.LastReconcileTime = time.Now()
            
            // 更新 Condition
            updateConditions(ctx, "Ready", "False", "Panic", fmt.Sprintf("%v", r))
            
            // 尝试更新状态
            ctx.Client.UpdateWebAppStatus(ctx.WebApp)
            
            // 记录事件
            ctx.Client.RecordEvent(Event{
                Type:    EventTypeWarning,
                Reason:  "ReconcilePanic",
                Message: fmt.Sprintf("协调过程中发生 Panic: %v", r),
                Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
            })
        }
    }()
    
    ctx.Logger.Info("Reconcile called", "webapp", ctx.WebApp.Name, "phase", ctx.WebApp.Status.Phase)
    
    // 更新 Progressing Condition
    updateConditions(ctx, "Progressing", "True", "Reconciling", "正在协调资源")
    
    var result ReconcileResult
    
    // 1. 检查是否正在删除
    if ctx.WebApp.DeletionTimestamp != nil {
        result = handleDeletion(ctx)
    } else {
        // 2. 根据当前状态选择执行路径
        switch ctx.WebApp.Status.Phase {
        case "", PhasePending:
            result = handlePending(ctx)
        case PhaseCreating:
            result = handleCreating(ctx)
        case PhaseRunning:
            result = handleRunning(ctx)
        case PhaseFailed:
            result = handleFailed(ctx)
        default:
            err := fmt.Errorf("unknown phase: %s", ctx.WebApp.Status.Phase)
            ctx.Logger.Error(err, "未知的状态")
            result = ReconcileResult{Error: err}
        }
    }
    
    // 更新 Ready Condition
    if result.Error == nil && ctx.WebApp.Status.Phase == PhaseRunning {
        updateConditions(ctx, "Ready", "True", "ResourcesReady", "所有资源已就绪")
    } else if result.Error != nil {
        updateConditions(ctx, "Ready", "False", "ReconcileError", result.Error.Error())
    }
    
    // 处理错误类型
    if result.Error != nil {
        if IsRetryableError(result.Error) {
            // 临时性错误，自动重试
            retryErr := result.Error.(*RetryableError)
            ctx.Logger.Info("临时性错误，将重试", "reason", retryErr.Reason, "after", retryErr.After)
            result.RequeueAfter = retryErr.After
        } else if IsPermanentError(result.Error) {
            // 永久性错误，转换到 Failed 状态
            ctx.Logger.Error(result.Error, "永久性错误，转换到 Failed 状态")
            ctx.WebApp.Status.Phase = PhaseFailed
            ctx.WebApp.Status.Message = result.Error.Error()
            ctx.WebApp.Status.LastReconcileTime = time.Now()
            ctx.Client.UpdateWebAppStatus(ctx.WebApp)
            
            // 记录事件
            ctx.Client.RecordEvent(Event{
                Type:    EventTypeWarning,
                Reason:  "PermanentError",
                Message: result.Error.Error(),
                Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
            })
            
            // 不重新入队
            result.Requeue = false
            result.Error = nil
        }
    }
    
    return result
}
```

### 2. 实现 updateConditions 函数

实现 Conditions 管理逻辑：

```go
func updateConditions(ctx *ReconcileContext, condType, status, reason, message string) {
    now := time.Now()
    
    // 查找现有 Condition
    found := false
    for i, cond := range ctx.WebApp.Status.Conditions {
        if cond.Type == condType {
            // 更新现有 Condition
            if cond.Status != status {
                // 状态变更，更新转换时间
                ctx.WebApp.Status.Conditions[i].Status = status
                ctx.WebApp.Status.Conditions[i].LastTransitionTime = now
                ctx.Logger.Info("Condition 状态变更",
                    "type", condType,
                    "oldStatus", cond.Status,
                    "newStatus", status)
            }
            ctx.WebApp.Status.Conditions[i].Reason = reason
            ctx.WebApp.Status.Conditions[i].Message = message
            found = true
            break
        }
    }
    
    // 添加新 Condition
    if !found {
        ctx.Logger.Info("添加新 Condition", "type", condType, "status", status)
        ctx.WebApp.Status.Conditions = append(ctx.WebApp.Status.Conditions, Condition{
            Type:               condType,
            Status:             status,
            LastTransitionTime: now,
            Reason:             reason,
            Message:            message,
        })
    }
}
```

### 3. 实现 handleFailed 函数

实现 Failed 状态的处理逻辑：

```go
func handleFailed(ctx *ReconcileContext) ReconcileResult {
    ctx.Logger.Info("处理 Failed 状态", "webapp", ctx.WebApp.Name)
    
    // Failed 状态通常需要人工介入
    // 但可以实现自动恢复逻辑
    
    // 检查 Spec 是否变更
    if specChanged(ctx) {
        ctx.Logger.Info("检测到 Spec 变更，尝试从 Failed 状态恢复")
        
        // 重置到 Pending 状态，重新开始
        ctx.WebApp.Status.Phase = PhasePending
        ctx.WebApp.Status.Message = "尝试从失败状态恢复"
        ctx.WebApp.Status.LastReconcileTime = time.Now()
        
        if err := ctx.Client.UpdateWebAppStatus(ctx.WebApp); err != nil {
            ctx.Logger.Error(err, "更新状态失败")
            return ReconcileResult{Error: err}
        }
        
        ctx.Logger.Info("状态已重置", "from", PhaseFailed, "to", PhasePending)
        
        // 记录事件
        ctx.Client.RecordEvent(Event{
            Type:    EventTypeNormal,
            Reason:  "RecoveryAttempt",
            Message: "检测到 Spec 变更，尝试从 Failed 状态恢复",
            Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
        })
        
        // 立即重新入队
        return ReconcileResult{Requeue: true}
    }
    
    // 没有 Spec 变更，保持 Failed 状态
    // 不重新入队，等待人工介入或 Spec 变更
    ctx.Logger.Info("保持 Failed 状态，等待人工介入或 Spec 变更")
    
    return ReconcileResult{}
}
```

### 4. 使用错误类型

在各个处理函数中使用错误类型：

```go
func ensureDeployment(ctx *ReconcileContext) error {
    // ... 创建 Deployment 的逻辑
    
    if err := ctx.Client.CreateDeployment(deployment); err != nil {
        // 判断错误类型
        if isNetworkError(err) {
            // 网络错误，临时性
            return NewRetryableError("创建 Deployment 失败: 网络错误", 10*time.Second)
        }
        if isInvalidImageError(err) {
            // 镜像无效，永久性
            return NewPermanentError(fmt.Sprintf("无效的镜像: %s", ctx.WebApp.Spec.Image))
        }
        // 其他错误，默认为临时性
        return NewRetryableError(fmt.Sprintf("创建 Deployment 失败: %v", err), 5*time.Second)
    }
    
    return nil
}

// 辅助函数：判断是否为网络错误
func isNetworkError(err error) bool {
    // 简化实现，实际应该检查错误类型
    return strings.Contains(err.Error(), "network") ||
           strings.Contains(err.Error(), "timeout")
}

// 辅助函数：判断是否为无效镜像错误
func isInvalidImageError(err error) bool {
    return strings.Contains(err.Error(), "invalid image") ||
           strings.Contains(err.Error(), "image not found")
}
```

### 5. 增强事件记录

在关键操作时记录详细的事件：

```go
// 成功事件
ctx.Client.RecordEvent(Event{
    Type:    EventTypeNormal,
    Reason:  "DeploymentCreated",
    Message: fmt.Sprintf("Deployment %s 已创建，Replicas: %d", name, replicas),
    Object:  fmt.Sprintf("%s/%s", namespace, name),
})

// 警告事件
ctx.Client.RecordEvent(Event{
    Type:    EventTypeWarning,
    Reason:  "DeploymentNotReady",
    Message: fmt.Sprintf("Deployment 未就绪: %d/%d", ready, desired),
    Object:  fmt.Sprintf("%s/%s", namespace, name),
})

// 错误事件
ctx.Client.RecordEvent(Event{
    Type:    EventTypeWarning,
    Reason:  "ReconcileError",
    Message: fmt.Sprintf("协调失败: %v", err),
    Object:  fmt.Sprintf("%s/%s", namespace, name),
})
```

## 实现步骤

### 步骤 1: 增强 Reconcile 函数

添加 Panic 恢复和 Conditions 管理。

### 步骤 2: 实现 updateConditions 函数

添加 Conditions 更新逻辑。

### 步骤 3: 实现 handleFailed 函数

添加 Failed 状态处理和恢复逻辑。

### 步骤 4: 更新错误处理

在各个函数中使用 RetryableError 和 PermanentError。

### 步骤 5: 增强事件记录

在关键操作时记录详细事件。

### 步骤 6: 测试

运行测试程序验证实现：

```bash
cd operator/ex3/framework
go run .
```

## 测试场景

创建一个测试程序来验证你的实现：

```go
func testExercise5() {
    fmt.Println("=== 测试练习 5: 错误处理与可观测性 ===")
    
    client := NewMockK8sClient()
    logger := &SimpleLogger{Name: "test"}
    
    // 场景 1: 正常协调，验证 Conditions
    fmt.Println("\n场景 1: 正常协调")
    webapp := &WebApp{
        Name:       "test-webapp",
        Namespace:  "default",
        Generation: 1,
        Spec: WebAppSpec{
            Image:    "nginx:latest",
            Replicas: 2,
            Port:     80,
        },
        Status: WebAppStatus{
            Phase: PhaseRunning,
        },
        Finalizers: []string{WebAppFinalizer},
    }
    
    client.CreateWebApp(webapp)
    
    // 创建资源
    deployment := &Deployment{
        Name:      "test-webapp",
        Namespace: "default",
        Spec: DeploymentSpec{
            Replicas: 2,
            Image:    "nginx:latest",
        },
        Status: DeploymentStatus{
            ReadyReplicas: 2,
        },
    }
    client.CreateDeployment(deployment)
    
    service := &Service{
        Name:      "test-webapp",
        Namespace: "default",
        Spec: ServiceSpec{
            Port: 80,
        },
    }
    client.CreateService(service)
    
    webapp, _ = client.GetWebApp("default", "test-webapp")
    ctx := NewReconcileContext(webapp, client, logger)
    Reconcile(ctx)
    
    webapp, _ = client.GetWebApp("default", "test-webapp")
    
    // 验证 Conditions
    fmt.Println("Conditions:")
    hasReady := false
    hasProgressing := false
    for _, cond := range webapp.Status.Conditions {
        fmt.Printf("  - Type: %s, Status: %s, Reason: %s\n",
            cond.Type, cond.Status, cond.Reason)
        if cond.Type == "Ready" && cond.Status == "True" {
            hasReady = true
        }
        if cond.Type == "Progressing" {
            hasProgressing = true
        }
    }
    
    if hasReady && hasProgressing {
        fmt.Println("✓ Conditions 正确设置")
    } else {
        fmt.Println("✗ Conditions 设置不完整")
    }
    
    // 场景 2: 模拟永久性错误
    fmt.Println("\n场景 2: 永久性错误")
    webapp2 := &WebApp{
        Name:       "invalid-webapp",
        Namespace:  "default",
        Generation: 1,
        Spec: WebAppSpec{
            Image:    "invalid-image:latest", // 无效镜像
            Replicas: 2,
            Port:     80,
        },
        Status: WebAppStatus{
            Phase: PhaseCreating,
        },
        Finalizers: []string{WebAppFinalizer},
    }
    
    client.CreateWebApp(webapp2)
    
    // 注意：在真实实现中，需要在 ensureDeployment 中检测无效镜像
    // 这里简化处理
    
    // 场景 3: 从 Failed 状态恢复
    fmt.Println("\n场景 3: 从 Failed 状态恢复")
    webapp3 := &WebApp{
        Name:       "failed-webapp",
        Namespace:  "default",
        Generation: 1,
        Spec: WebAppSpec{
            Image:    "nginx:latest",
            Replicas: 2,
            Port:     80,
        },
        Status: WebAppStatus{
            Phase:              PhaseFailed,
            Message:            "之前的错误",
            ObservedGeneration: 1,
        },
        Finalizers: []string{WebAppFinalizer},
    }
    
    client.CreateWebApp(webapp3)
    
    // 修改 Spec
    webapp3.Generation = 2
    webapp3.Spec.Replicas = 3
    client.UpdateWebApp(webapp3)
    
    webapp3, _ = client.GetWebApp("default", "failed-webapp")
    ctx = NewReconcileContext(webapp3, client, logger)
    result := Reconcile(ctx)
    
    webapp3, _ = client.GetWebApp("default", "failed-webapp")
    
    if webapp3.Status.Phase == PhasePending {
        fmt.Println("✓ 成功从 Failed 状态恢复到 Pending")
    } else {
        fmt.Printf("✗ 恢复失败，当前状态: %s\n", webapp3.Status.Phase)
    }
    
    // 显示事件统计
    events := client.GetEvents()
    fmt.Printf("\n总共记录了 %d 个事件\n", len(events))
    
    normalCount := 0
    warningCount := 0
    for _, event := range events {
        if event.Type == EventTypeNormal {
            normalCount++
        } else if event.Type == EventTypeWarning {
            warningCount++
        }
    }
    
    fmt.Printf("  Normal 事件: %d\n", normalCount)
    fmt.Printf("  Warning 事件: %d\n", warningCount)
}
```

## 预期输出

运行测试后，你应该看到类似的输出：

```
=== 测试练习 5: 错误处理与可观测性 ===

场景 1: 正常协调
[INFO] test: Reconcile called [webapp test-webapp phase Running]
[INFO] test: 处理 Running 状态 [webapp test-webapp]
[INFO] test: 添加新 Condition [type Progressing status True]
[INFO] test: 添加新 Condition [type Ready status True]
Conditions:
  - Type: Progressing, Status: True, Reason: Reconciling
  - Type: Ready, Status: True, Reason: ResourcesReady
✓ Conditions 正确设置

场景 2: 永久性错误
（根据实现可能有不同输出）

场景 3: 从 Failed 状态恢复
[INFO] test: Reconcile called [webapp failed-webapp phase Failed]
[INFO] test: 处理 Failed 状态 [webapp failed-webapp]
[INFO] test: 检测到 Spec 变更，尝试从 Failed 状态恢复 []
[INFO] test: 状态已重置 [from Failed to Pending]
✓ 成功从 Failed 状态恢复到 Pending

总共记录了 5 个事件
  Normal 事件: 4
  Warning 事件: 1
```

## 验证清单

完成练习后，确保：

- [ ] Panic 被正确捕获和恢复
- [ ] Conditions 正确更新
- [ ] Ready Condition 反映资源状态
- [ ] Progressing Condition 反映协调状态
- [ ] 临时性错误会自动重试
- [ ] 永久性错误转换到 Failed 状态
- [ ] Failed 状态可以恢复
- [ ] 事件记录完整
- [ ] 日志输出详细

## 关键要点

1. **错误分类**: 区分临时性和永久性错误，采取不同策略
2. **Panic 恢复**: 防止单个错误导致整个控制器崩溃
3. **Conditions**: 提供详细的状态信息，符合 Kubernetes 标准
4. **智能重试**: 使用 RequeueAfter 实现延迟重试
5. **可观测性**: 通过日志、事件、Conditions 提供完整的可观测性
6. **自动恢复**: Failed 状态可以在 Spec 变更时自动恢复

## 常见问题

### Q: 什么时候使用 RetryableError？

A: 当错误是临时性的，可能通过重试解决时使用，如网络超时、资源暂时不可用等。

### Q: 什么时候使用 PermanentError？

A: 当错误是永久性的，重试无法解决时使用，如配置错误、权限不足等。

### Q: Conditions 和 Phase 有什么区别？

A: Phase 是简单的状态枚举，Conditions 提供更详细的状态信息。一个资源可以有多个 Conditions。

### Q: 为什么要实现 Panic 恢复？

A: 防止单个资源的错误导致整个控制器崩溃，提高系统的健壮性。

### Q: Failed 状态什么时候会自动恢复？

A: 当检测到 Spec 变更时（Generation != ObservedGeneration），会尝试自动恢复。

## 参考答案

如果你完成了实现或遇到困难，可以查看参考答案：

```bash
cd operator/ex3/solutions/ex5
go run .        # 运行参考实现
go test -v      # 运行测试
```

参考答案位于 `solutions/ex5/` 目录。

## 完成所有练习

🎉 恭喜！完成所有 5 个练习后，你已经掌握了：

- ✅ 状态机驱动的协调循环
- ✅ 资源生命周期管理（创建、更新、删除）
- ✅ OwnerReference 和 Finalizer 机制
- ✅ 错误处理和重试策略
- ✅ 可观测性最佳实践

你现在具备了构建生产级 Kubernetes Operator 的能力！

## 进阶学习

继续学习的方向：

1. **性能优化**: 学习如何优化控制器性能
2. **并发控制**: 学习如何处理并发协调
3. **Webhook**: 学习如何实现 Admission Webhook
4. **真实集群**: 在真实 Kubernetes 集群中部署你的 Operator
5. **Kubebuilder**: 学习使用 Kubebuilder 框架

## 相关资源

- [Kubernetes Operator 最佳实践](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/)
- [Controller Runtime](https://github.com/kubernetes-sigs/controller-runtime)
- [Kubebuilder Book](https://book.kubebuilder.io/)
- [Operator SDK](https://sdk.operatorframework.io/)
