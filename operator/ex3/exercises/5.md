# ç»ƒä¹  5: é”™è¯¯å¤„ç†ä¸å¯è§‚æµ‹æ€§

## å­¦ä¹ ç›®æ ‡

åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œä½ å°†å­¦ä¹ ï¼š

1. å®ç°é”™è¯¯åˆ†ç±»ï¼ˆä¸´æ—¶æ€§ vs æ°¸ä¹…æ€§ï¼‰
2. å®ç°æ™ºèƒ½é‡è¯•ç­–ç•¥
3. å¢å¼º Status Conditions ç®¡ç†
4. å®ç° Panic æ¢å¤æœºåˆ¶
5. æå‡ç³»ç»Ÿå¯è§‚æµ‹æ€§
6. å®ç°ä» Failed çŠ¶æ€æ¢å¤

## èƒŒæ™¯çŸ¥è¯†

### é”™è¯¯åˆ†ç±»

åœ¨ Kubernetes Operator ä¸­ï¼Œæ­£ç¡®åˆ†ç±»é”™è¯¯éå¸¸é‡è¦ï¼š

**ä¸´æ—¶æ€§é”™è¯¯ï¼ˆRetryable Errorï¼‰**ï¼š
- ç½‘ç»œè¶…æ—¶
- èµ„æºæš‚æ—¶ä¸å¯ç”¨
- API Server é™æµ
- åº”è¯¥è‡ªåŠ¨é‡è¯•

**æ°¸ä¹…æ€§é”™è¯¯ï¼ˆPermanent Errorï¼‰**ï¼š
- é…ç½®é”™è¯¯ï¼ˆå¦‚æ— æ•ˆçš„é•œåƒåï¼‰
- æƒé™ä¸è¶³
- èµ„æºé…é¢è¶…é™
- ä¸åº”è¯¥æ— é™é‡è¯•ï¼Œéœ€è¦äººå·¥ä»‹å…¥

**é”™è¯¯ç±»å‹å®šä¹‰**ï¼š

```go
// RetryableError å¯é‡è¯•é”™è¯¯ï¼ˆä¸´æ—¶æ€§é”™è¯¯ï¼‰
type RetryableError struct {
    Reason string        // é”™è¯¯åŸå› 
    After  time.Duration // å»ºè®®é‡è¯•é—´éš”
}

func (e *RetryableError) Error() string {
    return fmt.Sprintf("retryable error: %s (retry after %v)", e.Reason, e.After)
}

// PermanentError æ°¸ä¹…æ€§é”™è¯¯
type PermanentError struct {
    Reason string // é”™è¯¯åŸå› 
}

func (e *PermanentError) Error() string {
    return fmt.Sprintf("permanent error: %s", e.Reason)
}
```

### Status Conditions

Conditions æä¾›èµ„æºçŠ¶æ€çš„è¯¦ç»†ä¿¡æ¯ï¼Œæ˜¯ Kubernetes çš„æ ‡å‡†åšæ³•ï¼š

```go
type Condition struct {
    Type               string    // æ¡ä»¶ç±»å‹ï¼Œå¦‚ "Ready", "Progressing"
    Status             string    // æ¡ä»¶çŠ¶æ€: "True", "False", "Unknown"
    LastTransitionTime time.Time // æœ€åè½¬æ¢æ—¶é—´
    Reason             string    // åŸå› ï¼ˆæœºå™¨å¯è¯»ï¼‰
    Message            string    // è¯¦ç»†æ¶ˆæ¯ï¼ˆäººç±»å¯è¯»ï¼‰
}
```

**å¸¸è§çš„ Condition ç±»å‹**ï¼š
- **Ready**: èµ„æºæ˜¯å¦å°±ç»ª
- **Progressing**: èµ„æºæ˜¯å¦æ­£åœ¨å¤„ç†ä¸­
- **Degraded**: èµ„æºæ˜¯å¦å¤„äºé™çº§çŠ¶æ€
- **Available**: èµ„æºæ˜¯å¦å¯ç”¨

**Condition çŠ¶æ€**ï¼š
- **True**: æ¡ä»¶æ»¡è¶³
- **False**: æ¡ä»¶ä¸æ»¡è¶³
- **Unknown**: çŠ¶æ€æœªçŸ¥

### Panic æ¢å¤

åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼ŒPanic å¯èƒ½å¯¼è‡´æ•´ä¸ªæ§åˆ¶å™¨å´©æºƒã€‚éœ€è¦å®ç° Panic æ¢å¤æœºåˆ¶ï¼š

```go
defer func() {
    if r := recover(); r != nil {
        // æ•è· panic
        // è®°å½•æ—¥å¿—
        // è½¬æ¢ä¸ºé”™è¯¯
    }
}()
```

### é‡è¯•ç­–ç•¥

**æŒ‡æ•°é€€é¿ï¼ˆExponential Backoffï¼‰**ï¼š

```
ç¬¬ 1 æ¬¡é‡è¯•: 1 ç§’å
ç¬¬ 2 æ¬¡é‡è¯•: 2 ç§’å
ç¬¬ 3 æ¬¡é‡è¯•: 4 ç§’å
ç¬¬ 4 æ¬¡é‡è¯•: 8 ç§’å
...
æœ€å¤§é—´éš”: 5 åˆ†é’Ÿ
```

**ä½¿ç”¨ RequeueAfter**ï¼š

```go
return ReconcileResult{
    Requeue:      true,
    RequeueAfter: 10 * time.Second, // 10 ç§’åé‡è¯•
}
```

## ä»»åŠ¡è¯´æ˜

åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œä½ éœ€è¦å¢å¼ºæ•´ä¸ªåè°ƒå¾ªç¯çš„é”™è¯¯å¤„ç†å’Œå¯è§‚æµ‹æ€§ï¼š

### 1. å¢å¼º Reconcile å‡½æ•°

æ·»åŠ  Panic æ¢å¤å’Œ Conditions ç®¡ç†ï¼š

```go
func Reconcile(ctx *ReconcileContext) ReconcileResult {
    // Panic æ¢å¤
    defer func() {
        if r := recover(); r != nil {
            ctx.Logger.Error(fmt.Errorf("%v", r), "Panic æ¢å¤")
            
            // è½¬æ¢åˆ° Failed çŠ¶æ€
            ctx.WebApp.Status.Phase = PhaseFailed
            ctx.WebApp.Status.Message = fmt.Sprintf("Panic: %v", r)
            ctx.WebApp.Status.LastReconcileTime = time.Now()
            
            // æ›´æ–° Condition
            updateConditions(ctx, "Ready", "False", "Panic", fmt.Sprintf("%v", r))
            
            // å°è¯•æ›´æ–°çŠ¶æ€
            ctx.Client.UpdateWebAppStatus(ctx.WebApp)
            
            // è®°å½•äº‹ä»¶
            ctx.Client.RecordEvent(Event{
                Type:    EventTypeWarning,
                Reason:  "ReconcilePanic",
                Message: fmt.Sprintf("åè°ƒè¿‡ç¨‹ä¸­å‘ç”Ÿ Panic: %v", r),
                Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
            })
        }
    }()
    
    ctx.Logger.Info("Reconcile called", "webapp", ctx.WebApp.Name, "phase", ctx.WebApp.Status.Phase)
    
    // æ›´æ–° Progressing Condition
    updateConditions(ctx, "Progressing", "True", "Reconciling", "æ­£åœ¨åè°ƒèµ„æº")
    
    var result ReconcileResult
    
    // 1. æ£€æŸ¥æ˜¯å¦æ­£åœ¨åˆ é™¤
    if ctx.WebApp.DeletionTimestamp != nil {
        result = handleDeletion(ctx)
    } else {
        // 2. æ ¹æ®å½“å‰çŠ¶æ€é€‰æ‹©æ‰§è¡Œè·¯å¾„
        switch ctx.WebApp.Status.Phase {
        case "", PhasePending:
            result = handlePending(ctx)
        case PhaseCreating:
            result = handleCreating(ctx)
        case PhaseRunning:
            result = handleRunning(ctx)
        case PhaseFailed:
            result = handleFailed(ctx)
        default:
            err := fmt.Errorf("unknown phase: %s", ctx.WebApp.Status.Phase)
            ctx.Logger.Error(err, "æœªçŸ¥çš„çŠ¶æ€")
            result = ReconcileResult{Error: err}
        }
    }
    
    // æ›´æ–° Ready Condition
    if result.Error == nil && ctx.WebApp.Status.Phase == PhaseRunning {
        updateConditions(ctx, "Ready", "True", "ResourcesReady", "æ‰€æœ‰èµ„æºå·²å°±ç»ª")
    } else if result.Error != nil {
        updateConditions(ctx, "Ready", "False", "ReconcileError", result.Error.Error())
    }
    
    // å¤„ç†é”™è¯¯ç±»å‹
    if result.Error != nil {
        if IsRetryableError(result.Error) {
            // ä¸´æ—¶æ€§é”™è¯¯ï¼Œè‡ªåŠ¨é‡è¯•
            retryErr := result.Error.(*RetryableError)
            ctx.Logger.Info("ä¸´æ—¶æ€§é”™è¯¯ï¼Œå°†é‡è¯•", "reason", retryErr.Reason, "after", retryErr.After)
            result.RequeueAfter = retryErr.After
        } else if IsPermanentError(result.Error) {
            // æ°¸ä¹…æ€§é”™è¯¯ï¼Œè½¬æ¢åˆ° Failed çŠ¶æ€
            ctx.Logger.Error(result.Error, "æ°¸ä¹…æ€§é”™è¯¯ï¼Œè½¬æ¢åˆ° Failed çŠ¶æ€")
            ctx.WebApp.Status.Phase = PhaseFailed
            ctx.WebApp.Status.Message = result.Error.Error()
            ctx.WebApp.Status.LastReconcileTime = time.Now()
            ctx.Client.UpdateWebAppStatus(ctx.WebApp)
            
            // è®°å½•äº‹ä»¶
            ctx.Client.RecordEvent(Event{
                Type:    EventTypeWarning,
                Reason:  "PermanentError",
                Message: result.Error.Error(),
                Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
            })
            
            // ä¸é‡æ–°å…¥é˜Ÿ
            result.Requeue = false
            result.Error = nil
        }
    }
    
    return result
}
```

### 2. å®ç° updateConditions å‡½æ•°

å®ç° Conditions ç®¡ç†é€»è¾‘ï¼š

```go
func updateConditions(ctx *ReconcileContext, condType, status, reason, message string) {
    now := time.Now()
    
    // æŸ¥æ‰¾ç°æœ‰ Condition
    found := false
    for i, cond := range ctx.WebApp.Status.Conditions {
        if cond.Type == condType {
            // æ›´æ–°ç°æœ‰ Condition
            if cond.Status != status {
                // çŠ¶æ€å˜æ›´ï¼Œæ›´æ–°è½¬æ¢æ—¶é—´
                ctx.WebApp.Status.Conditions[i].Status = status
                ctx.WebApp.Status.Conditions[i].LastTransitionTime = now
                ctx.Logger.Info("Condition çŠ¶æ€å˜æ›´",
                    "type", condType,
                    "oldStatus", cond.Status,
                    "newStatus", status)
            }
            ctx.WebApp.Status.Conditions[i].Reason = reason
            ctx.WebApp.Status.Conditions[i].Message = message
            found = true
            break
        }
    }
    
    // æ·»åŠ æ–° Condition
    if !found {
        ctx.Logger.Info("æ·»åŠ æ–° Condition", "type", condType, "status", status)
        ctx.WebApp.Status.Conditions = append(ctx.WebApp.Status.Conditions, Condition{
            Type:               condType,
            Status:             status,
            LastTransitionTime: now,
            Reason:             reason,
            Message:            message,
        })
    }
}
```

### 3. å®ç° handleFailed å‡½æ•°

å®ç° Failed çŠ¶æ€çš„å¤„ç†é€»è¾‘ï¼š

```go
func handleFailed(ctx *ReconcileContext) ReconcileResult {
    ctx.Logger.Info("å¤„ç† Failed çŠ¶æ€", "webapp", ctx.WebApp.Name)
    
    // Failed çŠ¶æ€é€šå¸¸éœ€è¦äººå·¥ä»‹å…¥
    // ä½†å¯ä»¥å®ç°è‡ªåŠ¨æ¢å¤é€»è¾‘
    
    // æ£€æŸ¥ Spec æ˜¯å¦å˜æ›´
    if specChanged(ctx) {
        ctx.Logger.Info("æ£€æµ‹åˆ° Spec å˜æ›´ï¼Œå°è¯•ä» Failed çŠ¶æ€æ¢å¤")
        
        // é‡ç½®åˆ° Pending çŠ¶æ€ï¼Œé‡æ–°å¼€å§‹
        ctx.WebApp.Status.Phase = PhasePending
        ctx.WebApp.Status.Message = "å°è¯•ä»å¤±è´¥çŠ¶æ€æ¢å¤"
        ctx.WebApp.Status.LastReconcileTime = time.Now()
        
        if err := ctx.Client.UpdateWebAppStatus(ctx.WebApp); err != nil {
            ctx.Logger.Error(err, "æ›´æ–°çŠ¶æ€å¤±è´¥")
            return ReconcileResult{Error: err}
        }
        
        ctx.Logger.Info("çŠ¶æ€å·²é‡ç½®", "from", PhaseFailed, "to", PhasePending)
        
        // è®°å½•äº‹ä»¶
        ctx.Client.RecordEvent(Event{
            Type:    EventTypeNormal,
            Reason:  "RecoveryAttempt",
            Message: "æ£€æµ‹åˆ° Spec å˜æ›´ï¼Œå°è¯•ä» Failed çŠ¶æ€æ¢å¤",
            Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
        })
        
        // ç«‹å³é‡æ–°å…¥é˜Ÿ
        return ReconcileResult{Requeue: true}
    }
    
    // æ²¡æœ‰ Spec å˜æ›´ï¼Œä¿æŒ Failed çŠ¶æ€
    // ä¸é‡æ–°å…¥é˜Ÿï¼Œç­‰å¾…äººå·¥ä»‹å…¥æˆ– Spec å˜æ›´
    ctx.Logger.Info("ä¿æŒ Failed çŠ¶æ€ï¼Œç­‰å¾…äººå·¥ä»‹å…¥æˆ– Spec å˜æ›´")
    
    return ReconcileResult{}
}
```

### 4. ä½¿ç”¨é”™è¯¯ç±»å‹

åœ¨å„ä¸ªå¤„ç†å‡½æ•°ä¸­ä½¿ç”¨é”™è¯¯ç±»å‹ï¼š

```go
func ensureDeployment(ctx *ReconcileContext) error {
    // ... åˆ›å»º Deployment çš„é€»è¾‘
    
    if err := ctx.Client.CreateDeployment(deployment); err != nil {
        // åˆ¤æ–­é”™è¯¯ç±»å‹
        if isNetworkError(err) {
            // ç½‘ç»œé”™è¯¯ï¼Œä¸´æ—¶æ€§
            return NewRetryableError("åˆ›å»º Deployment å¤±è´¥: ç½‘ç»œé”™è¯¯", 10*time.Second)
        }
        if isInvalidImageError(err) {
            // é•œåƒæ— æ•ˆï¼Œæ°¸ä¹…æ€§
            return NewPermanentError(fmt.Sprintf("æ— æ•ˆçš„é•œåƒ: %s", ctx.WebApp.Spec.Image))
        }
        // å…¶ä»–é”™è¯¯ï¼Œé»˜è®¤ä¸ºä¸´æ—¶æ€§
        return NewRetryableError(fmt.Sprintf("åˆ›å»º Deployment å¤±è´¥: %v", err), 5*time.Second)
    }
    
    return nil
}

// è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºç½‘ç»œé”™è¯¯
func isNetworkError(err error) bool {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥æ£€æŸ¥é”™è¯¯ç±»å‹
    return strings.Contains(err.Error(), "network") ||
           strings.Contains(err.Error(), "timeout")
}

// è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºæ— æ•ˆé•œåƒé”™è¯¯
func isInvalidImageError(err error) bool {
    return strings.Contains(err.Error(), "invalid image") ||
           strings.Contains(err.Error(), "image not found")
}
```

### 5. å¢å¼ºäº‹ä»¶è®°å½•

åœ¨å…³é”®æ“ä½œæ—¶è®°å½•è¯¦ç»†çš„äº‹ä»¶ï¼š

```go
// æˆåŠŸäº‹ä»¶
ctx.Client.RecordEvent(Event{
    Type:    EventTypeNormal,
    Reason:  "DeploymentCreated",
    Message: fmt.Sprintf("Deployment %s å·²åˆ›å»ºï¼ŒReplicas: %d", name, replicas),
    Object:  fmt.Sprintf("%s/%s", namespace, name),
})

// è­¦å‘Šäº‹ä»¶
ctx.Client.RecordEvent(Event{
    Type:    EventTypeWarning,
    Reason:  "DeploymentNotReady",
    Message: fmt.Sprintf("Deployment æœªå°±ç»ª: %d/%d", ready, desired),
    Object:  fmt.Sprintf("%s/%s", namespace, name),
})

// é”™è¯¯äº‹ä»¶
ctx.Client.RecordEvent(Event{
    Type:    EventTypeWarning,
    Reason:  "ReconcileError",
    Message: fmt.Sprintf("åè°ƒå¤±è´¥: %v", err),
    Object:  fmt.Sprintf("%s/%s", namespace, name),
})
```

## å®ç°æ­¥éª¤

### æ­¥éª¤ 1: å¢å¼º Reconcile å‡½æ•°

æ·»åŠ  Panic æ¢å¤å’Œ Conditions ç®¡ç†ã€‚

### æ­¥éª¤ 2: å®ç° updateConditions å‡½æ•°

æ·»åŠ  Conditions æ›´æ–°é€»è¾‘ã€‚

### æ­¥éª¤ 3: å®ç° handleFailed å‡½æ•°

æ·»åŠ  Failed çŠ¶æ€å¤„ç†å’Œæ¢å¤é€»è¾‘ã€‚

### æ­¥éª¤ 4: æ›´æ–°é”™è¯¯å¤„ç†

åœ¨å„ä¸ªå‡½æ•°ä¸­ä½¿ç”¨ RetryableError å’Œ PermanentErrorã€‚

### æ­¥éª¤ 5: å¢å¼ºäº‹ä»¶è®°å½•

åœ¨å…³é”®æ“ä½œæ—¶è®°å½•è¯¦ç»†äº‹ä»¶ã€‚

### æ­¥éª¤ 6: æµ‹è¯•

è¿è¡Œæµ‹è¯•ç¨‹åºéªŒè¯å®ç°ï¼š

```bash
cd operator/ex3/framework
go run .
```

## æµ‹è¯•åœºæ™¯

åˆ›å»ºä¸€ä¸ªæµ‹è¯•ç¨‹åºæ¥éªŒè¯ä½ çš„å®ç°ï¼š

```go
func testExercise5() {
    fmt.Println("=== æµ‹è¯•ç»ƒä¹  5: é”™è¯¯å¤„ç†ä¸å¯è§‚æµ‹æ€§ ===")
    
    client := NewMockK8sClient()
    logger := &SimpleLogger{Name: "test"}
    
    // åœºæ™¯ 1: æ­£å¸¸åè°ƒï¼ŒéªŒè¯ Conditions
    fmt.Println("\nåœºæ™¯ 1: æ­£å¸¸åè°ƒ")
    webapp := &WebApp{
        Name:       "test-webapp",
        Namespace:  "default",
        Generation: 1,
        Spec: WebAppSpec{
            Image:    "nginx:latest",
            Replicas: 2,
            Port:     80,
        },
        Status: WebAppStatus{
            Phase: PhaseRunning,
        },
        Finalizers: []string{WebAppFinalizer},
    }
    
    client.CreateWebApp(webapp)
    
    // åˆ›å»ºèµ„æº
    deployment := &Deployment{
        Name:      "test-webapp",
        Namespace: "default",
        Spec: DeploymentSpec{
            Replicas: 2,
            Image:    "nginx:latest",
        },
        Status: DeploymentStatus{
            ReadyReplicas: 2,
        },
    }
    client.CreateDeployment(deployment)
    
    service := &Service{
        Name:      "test-webapp",
        Namespace: "default",
        Spec: ServiceSpec{
            Port: 80,
        },
    }
    client.CreateService(service)
    
    webapp, _ = client.GetWebApp("default", "test-webapp")
    ctx := NewReconcileContext(webapp, client, logger)
    Reconcile(ctx)
    
    webapp, _ = client.GetWebApp("default", "test-webapp")
    
    // éªŒè¯ Conditions
    fmt.Println("Conditions:")
    hasReady := false
    hasProgressing := false
    for _, cond := range webapp.Status.Conditions {
        fmt.Printf("  - Type: %s, Status: %s, Reason: %s\n",
            cond.Type, cond.Status, cond.Reason)
        if cond.Type == "Ready" && cond.Status == "True" {
            hasReady = true
        }
        if cond.Type == "Progressing" {
            hasProgressing = true
        }
    }
    
    if hasReady && hasProgressing {
        fmt.Println("âœ“ Conditions æ­£ç¡®è®¾ç½®")
    } else {
        fmt.Println("âœ— Conditions è®¾ç½®ä¸å®Œæ•´")
    }
    
    // åœºæ™¯ 2: æ¨¡æ‹Ÿæ°¸ä¹…æ€§é”™è¯¯
    fmt.Println("\nåœºæ™¯ 2: æ°¸ä¹…æ€§é”™è¯¯")
    webapp2 := &WebApp{
        Name:       "invalid-webapp",
        Namespace:  "default",
        Generation: 1,
        Spec: WebAppSpec{
            Image:    "invalid-image:latest", // æ— æ•ˆé•œåƒ
            Replicas: 2,
            Port:     80,
        },
        Status: WebAppStatus{
            Phase: PhaseCreating,
        },
        Finalizers: []string{WebAppFinalizer},
    }
    
    client.CreateWebApp(webapp2)
    
    // æ³¨æ„ï¼šåœ¨çœŸå®å®ç°ä¸­ï¼Œéœ€è¦åœ¨ ensureDeployment ä¸­æ£€æµ‹æ— æ•ˆé•œåƒ
    // è¿™é‡Œç®€åŒ–å¤„ç†
    
    // åœºæ™¯ 3: ä» Failed çŠ¶æ€æ¢å¤
    fmt.Println("\nåœºæ™¯ 3: ä» Failed çŠ¶æ€æ¢å¤")
    webapp3 := &WebApp{
        Name:       "failed-webapp",
        Namespace:  "default",
        Generation: 1,
        Spec: WebAppSpec{
            Image:    "nginx:latest",
            Replicas: 2,
            Port:     80,
        },
        Status: WebAppStatus{
            Phase:              PhaseFailed,
            Message:            "ä¹‹å‰çš„é”™è¯¯",
            ObservedGeneration: 1,
        },
        Finalizers: []string{WebAppFinalizer},
    }
    
    client.CreateWebApp(webapp3)
    
    // ä¿®æ”¹ Spec
    webapp3.Generation = 2
    webapp3.Spec.Replicas = 3
    client.UpdateWebApp(webapp3)
    
    webapp3, _ = client.GetWebApp("default", "failed-webapp")
    ctx = NewReconcileContext(webapp3, client, logger)
    result := Reconcile(ctx)
    
    webapp3, _ = client.GetWebApp("default", "failed-webapp")
    
    if webapp3.Status.Phase == PhasePending {
        fmt.Println("âœ“ æˆåŠŸä» Failed çŠ¶æ€æ¢å¤åˆ° Pending")
    } else {
        fmt.Printf("âœ— æ¢å¤å¤±è´¥ï¼Œå½“å‰çŠ¶æ€: %s\n", webapp3.Status.Phase)
    }
    
    // æ˜¾ç¤ºäº‹ä»¶ç»Ÿè®¡
    events := client.GetEvents()
    fmt.Printf("\næ€»å…±è®°å½•äº† %d ä¸ªäº‹ä»¶\n", len(events))
    
    normalCount := 0
    warningCount := 0
    for _, event := range events {
        if event.Type == EventTypeNormal {
            normalCount++
        } else if event.Type == EventTypeWarning {
            warningCount++
        }
    }
    
    fmt.Printf("  Normal äº‹ä»¶: %d\n", normalCount)
    fmt.Printf("  Warning äº‹ä»¶: %d\n", warningCount)
}
```

## é¢„æœŸè¾“å‡º

è¿è¡Œæµ‹è¯•åï¼Œä½ åº”è¯¥çœ‹åˆ°ç±»ä¼¼çš„è¾“å‡ºï¼š

```
=== æµ‹è¯•ç»ƒä¹  5: é”™è¯¯å¤„ç†ä¸å¯è§‚æµ‹æ€§ ===

åœºæ™¯ 1: æ­£å¸¸åè°ƒ
[INFO] test: Reconcile called [webapp test-webapp phase Running]
[INFO] test: å¤„ç† Running çŠ¶æ€ [webapp test-webapp]
[INFO] test: æ·»åŠ æ–° Condition [type Progressing status True]
[INFO] test: æ·»åŠ æ–° Condition [type Ready status True]
Conditions:
  - Type: Progressing, Status: True, Reason: Reconciling
  - Type: Ready, Status: True, Reason: ResourcesReady
âœ“ Conditions æ­£ç¡®è®¾ç½®

åœºæ™¯ 2: æ°¸ä¹…æ€§é”™è¯¯
ï¼ˆæ ¹æ®å®ç°å¯èƒ½æœ‰ä¸åŒè¾“å‡ºï¼‰

åœºæ™¯ 3: ä» Failed çŠ¶æ€æ¢å¤
[INFO] test: Reconcile called [webapp failed-webapp phase Failed]
[INFO] test: å¤„ç† Failed çŠ¶æ€ [webapp failed-webapp]
[INFO] test: æ£€æµ‹åˆ° Spec å˜æ›´ï¼Œå°è¯•ä» Failed çŠ¶æ€æ¢å¤ []
[INFO] test: çŠ¶æ€å·²é‡ç½® [from Failed to Pending]
âœ“ æˆåŠŸä» Failed çŠ¶æ€æ¢å¤åˆ° Pending

æ€»å…±è®°å½•äº† 5 ä¸ªäº‹ä»¶
  Normal äº‹ä»¶: 4
  Warning äº‹ä»¶: 1
```

## éªŒè¯æ¸…å•

å®Œæˆç»ƒä¹ åï¼Œç¡®ä¿ï¼š

- [ ] Panic è¢«æ­£ç¡®æ•è·å’Œæ¢å¤
- [ ] Conditions æ­£ç¡®æ›´æ–°
- [ ] Ready Condition åæ˜ èµ„æºçŠ¶æ€
- [ ] Progressing Condition åæ˜ åè°ƒçŠ¶æ€
- [ ] ä¸´æ—¶æ€§é”™è¯¯ä¼šè‡ªåŠ¨é‡è¯•
- [ ] æ°¸ä¹…æ€§é”™è¯¯è½¬æ¢åˆ° Failed çŠ¶æ€
- [ ] Failed çŠ¶æ€å¯ä»¥æ¢å¤
- [ ] äº‹ä»¶è®°å½•å®Œæ•´
- [ ] æ—¥å¿—è¾“å‡ºè¯¦ç»†

## å…³é”®è¦ç‚¹

1. **é”™è¯¯åˆ†ç±»**: åŒºåˆ†ä¸´æ—¶æ€§å’Œæ°¸ä¹…æ€§é”™è¯¯ï¼Œé‡‡å–ä¸åŒç­–ç•¥
2. **Panic æ¢å¤**: é˜²æ­¢å•ä¸ªé”™è¯¯å¯¼è‡´æ•´ä¸ªæ§åˆ¶å™¨å´©æºƒ
3. **Conditions**: æä¾›è¯¦ç»†çš„çŠ¶æ€ä¿¡æ¯ï¼Œç¬¦åˆ Kubernetes æ ‡å‡†
4. **æ™ºèƒ½é‡è¯•**: ä½¿ç”¨ RequeueAfter å®ç°å»¶è¿Ÿé‡è¯•
5. **å¯è§‚æµ‹æ€§**: é€šè¿‡æ—¥å¿—ã€äº‹ä»¶ã€Conditions æä¾›å®Œæ•´çš„å¯è§‚æµ‹æ€§
6. **è‡ªåŠ¨æ¢å¤**: Failed çŠ¶æ€å¯ä»¥åœ¨ Spec å˜æ›´æ—¶è‡ªåŠ¨æ¢å¤

## å¸¸è§é—®é¢˜

### Q: ä»€ä¹ˆæ—¶å€™ä½¿ç”¨ RetryableErrorï¼Ÿ

A: å½“é”™è¯¯æ˜¯ä¸´æ—¶æ€§çš„ï¼Œå¯èƒ½é€šè¿‡é‡è¯•è§£å†³æ—¶ä½¿ç”¨ï¼Œå¦‚ç½‘ç»œè¶…æ—¶ã€èµ„æºæš‚æ—¶ä¸å¯ç”¨ç­‰ã€‚

### Q: ä»€ä¹ˆæ—¶å€™ä½¿ç”¨ PermanentErrorï¼Ÿ

A: å½“é”™è¯¯æ˜¯æ°¸ä¹…æ€§çš„ï¼Œé‡è¯•æ— æ³•è§£å†³æ—¶ä½¿ç”¨ï¼Œå¦‚é…ç½®é”™è¯¯ã€æƒé™ä¸è¶³ç­‰ã€‚

### Q: Conditions å’Œ Phase æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

A: Phase æ˜¯ç®€å•çš„çŠ¶æ€æšä¸¾ï¼ŒConditions æä¾›æ›´è¯¦ç»†çš„çŠ¶æ€ä¿¡æ¯ã€‚ä¸€ä¸ªèµ„æºå¯ä»¥æœ‰å¤šä¸ª Conditionsã€‚

### Q: ä¸ºä»€ä¹ˆè¦å®ç° Panic æ¢å¤ï¼Ÿ

A: é˜²æ­¢å•ä¸ªèµ„æºçš„é”™è¯¯å¯¼è‡´æ•´ä¸ªæ§åˆ¶å™¨å´©æºƒï¼Œæé«˜ç³»ç»Ÿçš„å¥å£®æ€§ã€‚

### Q: Failed çŠ¶æ€ä»€ä¹ˆæ—¶å€™ä¼šè‡ªåŠ¨æ¢å¤ï¼Ÿ

A: å½“æ£€æµ‹åˆ° Spec å˜æ›´æ—¶ï¼ˆGeneration != ObservedGenerationï¼‰ï¼Œä¼šå°è¯•è‡ªåŠ¨æ¢å¤ã€‚

## å‚è€ƒç­”æ¡ˆ

å¦‚æœä½ å®Œæˆäº†å®ç°æˆ–é‡åˆ°å›°éš¾ï¼Œå¯ä»¥æŸ¥çœ‹å‚è€ƒç­”æ¡ˆï¼š

```bash
cd operator/ex3/solutions/ex5
go run .        # è¿è¡Œå‚è€ƒå®ç°
go test -v      # è¿è¡Œæµ‹è¯•
```

å‚è€ƒç­”æ¡ˆä½äº `solutions/ex5/` ç›®å½•ã€‚

## å®Œæˆæ‰€æœ‰ç»ƒä¹ 

ğŸ‰ æ­å–œï¼å®Œæˆæ‰€æœ‰ 5 ä¸ªç»ƒä¹ åï¼Œä½ å·²ç»æŒæ¡äº†ï¼š

- âœ… çŠ¶æ€æœºé©±åŠ¨çš„åè°ƒå¾ªç¯
- âœ… èµ„æºç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼ˆåˆ›å»ºã€æ›´æ–°ã€åˆ é™¤ï¼‰
- âœ… OwnerReference å’Œ Finalizer æœºåˆ¶
- âœ… é”™è¯¯å¤„ç†å’Œé‡è¯•ç­–ç•¥
- âœ… å¯è§‚æµ‹æ€§æœ€ä½³å®è·µ

ä½ ç°åœ¨å…·å¤‡äº†æ„å»ºç”Ÿäº§çº§ Kubernetes Operator çš„èƒ½åŠ›ï¼

## è¿›é˜¶å­¦ä¹ 

ç»§ç»­å­¦ä¹ çš„æ–¹å‘ï¼š

1. **æ€§èƒ½ä¼˜åŒ–**: å­¦ä¹ å¦‚ä½•ä¼˜åŒ–æ§åˆ¶å™¨æ€§èƒ½
2. **å¹¶å‘æ§åˆ¶**: å­¦ä¹ å¦‚ä½•å¤„ç†å¹¶å‘åè°ƒ
3. **Webhook**: å­¦ä¹ å¦‚ä½•å®ç° Admission Webhook
4. **çœŸå®é›†ç¾¤**: åœ¨çœŸå® Kubernetes é›†ç¾¤ä¸­éƒ¨ç½²ä½ çš„ Operator
5. **Kubebuilder**: å­¦ä¹ ä½¿ç”¨ Kubebuilder æ¡†æ¶

## ç›¸å…³èµ„æº

- [Kubernetes Operator æœ€ä½³å®è·µ](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/)
- [Controller Runtime](https://github.com/kubernetes-sigs/controller-runtime)
- [Kubebuilder Book](https://book.kubebuilder.io/)
- [Operator SDK](https://sdk.operatorframework.io/)
