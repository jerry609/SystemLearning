# 练习 1: 状态机与基础协调循环

## 学习目标

在这个练习中，你将学习：

1. 理解 Kubernetes Operator 的状态机模式
2. 实现基础的协调循环（Reconciliation Loop）
3. 掌握状态转换的基本逻辑
4. 了解 Finalizer 的作用和使用方法

## 背景知识

### 什么是协调循环？

Kubernetes Operator 的核心是**协调循环**（Reconciliation Loop），它的工作原理是：

1. **监听资源变化**: 通过 Watch 机制监听自定义资源的变化
2. **获取当前状态**: 从 API Server 获取资源的当前状态
3. **对比期望状态**: 将当前状态与期望状态（Spec）进行对比
4. **执行协调操作**: 执行必要的操作使当前状态趋向期望状态
5. **更新状态**: 更新资源的 Status 子资源
6. **重新入队**: 如果需要，将资源重新入队以便后续处理

### 什么是状态机？

状态机是一种设计模式，用于管理对象在不同阶段的行为。在 Operator 中，我们使用状态机来清晰地表达资源的生命周期：

```
Pending → Creating → Running → Deleting → (删除)
   ↓         ↓          ↓
   └────→ Failed ←──────┘
```

每个状态都有明确的职责：

- **Pending**: 初始状态，资源刚被创建，等待处理
- **Creating**: 正在创建依赖的 Kubernetes 资源（Deployment、Service）
- **Running**: 所有资源已创建并就绪，正常运行中
- **Failed**: 遇到永久性错误，需要人工介入
- **Deleting**: 资源正在被删除，执行清理操作

### 什么是 Finalizer？

Finalizer 是 Kubernetes 的一种机制，用于在资源被删除前执行清理操作。

当资源被标记删除时（`kubectl delete`）：
1. Kubernetes 设置 `DeletionTimestamp` 字段
2. 资源不会立即删除，而是等待所有 Finalizer 被移除
3. Operator 检测到 `DeletionTimestamp`，执行清理逻辑
4. 清理完成后，Operator 移除 Finalizer
5. Kubernetes 最终删除资源

## 任务说明

在这个练习中，你需要实现：

### 1. 状态机引擎

在 `reconcile.go` 中实现 `Reconcile` 函数，根据资源的当前状态选择执行路径：

```go
func Reconcile(ctx *ReconcileContext) ReconcileResult {
    // 1. 检查是否正在删除
    if ctx.WebApp.DeletionTimestamp != nil {
        return handleDeletion(ctx)
    }
    
    // 2. 根据当前状态选择执行路径
    switch ctx.WebApp.Status.Phase {
    case "", PhasePending:
        return handlePending(ctx)
    case PhaseCreating:
        return handleCreating(ctx)
    case PhaseRunning:
        return handleRunning(ctx)
    case PhaseFailed:
        return handleFailed(ctx)
    default:
        return ReconcileResult{Error: fmt.Errorf("unknown phase: %s", ctx.WebApp.Status.Phase)}
    }
}
```

### 2. Pending 状态处理

实现 `handlePending` 函数，处理资源的初始化：

```go
func handlePending(ctx *ReconcileContext) ReconcileResult {
    ctx.Logger.Info("处理 Pending 状态", "webapp", ctx.WebApp.Name)
    
    // 步骤 1: 添加 Finalizer
    if !hasFinalizer(ctx.WebApp, WebAppFinalizer) {
        addFinalizer(ctx.WebApp, WebAppFinalizer)
        if err := ctx.Client.UpdateWebApp(ctx.WebApp); err != nil {
            ctx.Logger.Error(err, "添加 Finalizer 失败")
            return ReconcileResult{Error: err}
        }
        ctx.Logger.Info("已添加 Finalizer")
        
        // 记录事件
        ctx.Client.RecordEvent(Event{
            Type:    EventTypeNormal,
            Reason:  "FinalizerAdded",
            Message: "Finalizer 已添加",
            Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
        })
    }
    
    // 步骤 2: 转换到 Creating 状态
    ctx.WebApp.Status.Phase = PhaseCreating
    ctx.WebApp.Status.Message = "开始创建依赖资源"
    ctx.WebApp.Status.LastReconcileTime = time.Now()
    
    if err := ctx.Client.UpdateWebAppStatus(ctx.WebApp); err != nil {
        ctx.Logger.Error(err, "更新状态失败")
        return ReconcileResult{Error: err}
    }
    
    ctx.Logger.Info("状态已转换", "from", PhasePending, "to", PhaseCreating)
    
    // 记录事件
    ctx.Client.RecordEvent(Event{
        Type:    EventTypeNormal,
        Reason:  "StateTransition",
        Message: fmt.Sprintf("状态从 %s 转换到 %s", PhasePending, PhaseCreating),
        Object:  fmt.Sprintf("%s/%s", ctx.WebApp.Namespace, ctx.WebApp.Name),
    })
    
    // 立即重新入队以处理 Creating 状态
    return ReconcileResult{Requeue: true}
}
```

### 3. Finalizer 辅助函数

实现 Finalizer 相关的辅助函数：

```go
const WebAppFinalizer = "webapp.example.com/finalizer"

// hasFinalizer 检查资源是否有指定的 Finalizer
func hasFinalizer(webapp *WebApp, finalizer string) bool {
    for _, f := range webapp.Finalizers {
        if f == finalizer {
            return true
        }
    }
    return false
}

// addFinalizer 添加 Finalizer
func addFinalizer(webapp *WebApp, finalizer string) {
    if !hasFinalizer(webapp, finalizer) {
        webapp.Finalizers = append(webapp.Finalizers, finalizer)
    }
}

// removeFinalizer 移除 Finalizer
func removeFinalizer(webapp *WebApp, finalizer string) {
    finalizers := []string{}
    for _, f := range webapp.Finalizers {
        if f != finalizer {
            finalizers = append(finalizers, f)
        }
    }
    webapp.Finalizers = finalizers
}
```

### 4. 占位符函数

为其他状态创建占位符函数（在后续练习中实现）：

```go
func handleCreating(ctx *ReconcileContext) ReconcileResult {
    ctx.Logger.Info("处理 Creating 状态（待实现）", "webapp", ctx.WebApp.Name)
    // TODO: 在练习 2 中实现
    return ReconcileResult{}
}

func handleRunning(ctx *ReconcileContext) ReconcileResult {
    ctx.Logger.Info("处理 Running 状态（待实现）", "webapp", ctx.WebApp.Name)
    // TODO: 在练习 3 中实现
    return ReconcileResult{}
}

func handleFailed(ctx *ReconcileContext) ReconcileResult {
    ctx.Logger.Info("处理 Failed 状态（待实现）", "webapp", ctx.WebApp.Name)
    // TODO: 在练习 5 中实现
    return ReconcileResult{}
}

func handleDeletion(ctx *ReconcileContext) ReconcileResult {
    ctx.Logger.Info("处理删除（待实现）", "webapp", ctx.WebApp.Name)
    // TODO: 在练习 4 中实现
    return ReconcileResult{}
}
```

## 实现步骤

### 步骤 1: 实现 Finalizer 辅助函数

在 `reconcile.go` 中添加 Finalizer 相关的常量和辅助函数。

### 步骤 2: 实现 handlePending 函数

实现 Pending 状态的处理逻辑，包括：
- 添加 Finalizer
- 转换到 Creating 状态
- 记录事件

### 步骤 3: 实现状态机引擎

实现 `Reconcile` 函数，根据当前状态分发到不同的处理函数。

### 步骤 4: 创建占位符函数

为其他状态创建占位符函数，以便代码能够编译通过。

### 步骤 5: 测试

运行测试程序验证实现：

```bash
cd operator/ex3/framework
go run .
```

或者运行单元测试：

```bash
cd operator/ex3/framework
go test -v
```

## 测试场景

创建一个测试程序来验证你的实现：

```go
func testExercise1() {
    fmt.Println("=== 测试练习 1: 状态机与基础协调循环 ===\n")
    
    // 创建客户端和日志器
    client := NewMockK8sClient()
    logger := &SimpleLogger{Name: "test"}
    
    // 场景 1: 新创建的资源（无状态）
    fmt.Println("场景 1: 处理新创建的资源")
    webapp := &WebApp{
        Name:      "test-webapp",
        Namespace: "default",
        Generation: 1,
        Spec: WebAppSpec{
            Image:    "nginx:latest",
            Replicas: 2,
            Port:     80,
        },
        Status: WebAppStatus{
            Phase: "", // 空状态
        },
    }
    
    client.CreateWebApp(webapp)
    webapp, _ = client.GetWebApp("default", "test-webapp")
    
    ctx := NewReconcileContext(webapp, client, logger)
    result := Reconcile(ctx)
    
    fmt.Printf("  协调结果: Requeue=%v, Error=%v\n", result.Requeue, result.Error)
    
    // 验证 Finalizer 已添加
    webapp, _ = client.GetWebApp("default", "test-webapp")
    fmt.Printf("  Finalizer 已添加: %v\n", hasFinalizer(webapp, WebAppFinalizer))
    fmt.Printf("  当前状态: %s\n", webapp.Status.Phase)
    fmt.Printf("  状态消息: %s\n\n", webapp.Status.Message)
    
    // 场景 2: 再次协调（应该进入 Creating 状态）
    fmt.Println("场景 2: 再次协调（进入 Creating 状态）")
    webapp, _ = client.GetWebApp("default", "test-webapp")
    ctx = NewReconcileContext(webapp, client, logger)
    result = Reconcile(ctx)
    
    fmt.Printf("  协调结果: Requeue=%v, Error=%v\n", result.Requeue, result.Error)
    fmt.Printf("  当前状态: %s\n\n", webapp.Status.Phase)
    
    // 显示事件
    events := client.GetEvents()
    fmt.Printf("记录的事件 (%d 个):\n", len(events))
    for i, event := range events {
        fmt.Printf("  %d. [%s] %s: %s\n", i+1, event.Type, event.Reason, event.Message)
    }
}
```

## 预期输出

运行测试后，你应该看到类似的输出：

```
=== 测试练习 1: 状态机与基础协调循环 ===

场景 1: 处理新创建的资源
[INFO] test: 处理 Pending 状态 [webapp test-webapp]
[INFO] test: 已添加 Finalizer []
[INFO] test: 状态已转换 [from Pending to Creating]
  协调结果: Requeue=true, Error=<nil>
  Finalizer 已添加: true
  当前状态: Creating
  状态消息: 开始创建依赖资源

场景 2: 再次协调（进入 Creating 状态）
[INFO] test: 处理 Creating 状态（待实现） [webapp test-webapp]
  协调结果: Requeue=false, Error=<nil>
  当前状态: Creating

记录的事件 (2 个):
  1. [Normal] FinalizerAdded: Finalizer 已添加
  2. [Normal] StateTransition: 状态从 Pending 转换到 Creating
```

## 验证清单

完成练习后，确保：

- [ ] `Reconcile` 函数能够根据状态正确分发
- [ ] `handlePending` 函数能够添加 Finalizer
- [ ] `handlePending` 函数能够转换状态到 Creating
- [ ] Finalizer 辅助函数工作正常
- [ ] 事件被正确记录
- [ ] 测试程序运行成功

## 关键要点

1. **状态机模式**: 使用状态机清晰地表达资源的生命周期
2. **Finalizer**: 在资源初始化时添加 Finalizer，确保删除时能执行清理
3. **状态转换**: 每次状态转换都应该记录事件和日志
4. **重新入队**: 状态转换后立即重新入队，以便处理新状态
5. **幂等性**: 检查 Finalizer 是否已存在，避免重复添加

## 常见问题

### Q: 为什么要在 Pending 状态添加 Finalizer？

A: Finalizer 应该在资源生命周期的早期添加，确保即使在创建过程中资源被删除，也能执行清理操作。

### Q: 为什么状态转换后要立即重新入队？

A: 重新入队可以让协调循环立即处理新状态，而不是等待下一次触发。这样可以加快资源的处理速度。

### Q: 如果添加 Finalizer 失败怎么办？

A: 返回错误，协调循环会自动重试。Kubernetes 的控制器框架会处理重试逻辑。

## 参考答案

如果你完成了实现或遇到困难，可以查看参考答案：

```bash
cd operator/ex3/solutions/ex1
go run .        # 运行参考实现
go test -v      # 运行测试
```

参考答案位于 `solutions/ex1/` 目录。

## 下一步

完成这个练习后，继续 [练习 2: 资源创建与管理](./2.md)，学习如何创建和管理依赖的 Kubernetes 资源。
