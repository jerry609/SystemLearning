练习 4: 批量资源同步器 (Batch Resource Synchronizer)

目标:

构建一个能够同步一个**资源集合**的流水线。你需要定义一个“期望状态”的资源清单，流水线会自动检查当前世界中的所有资源，然后执行必要的创建、更新和**删除**操作，以确保真实世界最终与期望状态完全一致。

这个练习将是之前所有概念的集大成者，并让你掌握：
1. 声明式状态同步: 你只需声明一个最终的期望状态（a list of resources），剩下的交给流水线。
2. 动态循环与决策: 在一个步骤内循环处理多个资源，并为每个资源做出独立的 Create 或 Update 决定。
3. 垃圾回收 (Garbage Collection): 实现一个步骤，用于删除那些“不应该存在”的资源。
4. 组合与重用: 你将再次看到，之前创建的 CreateStep 和 UpdateStep 等原子操作可以被新的、更宏观的步骤（如 SyncStep）所编排和调用。
  

---

任务要求

1. 扩展 Context

我们需要一个新的 Context 来持有我们的“期望状态清单”。

- SyncContext struct**:
  - DesiredState (map[string]map[string]string): 我们期望的最终状态。Key 是资源名，Value 是该资源的属性。
  - ManagedResources (map[string]bool): 一个内部跟踪器。在同步过程中，每处理一个期望的资源，就将其名字记录到这里。这对于后续的垃圾回收至关重要。
    
2. 实现核心同步步骤 (SyncStep)

这是本次练习的绝对核心。这个步骤负责将 worldState 向 DesiredState 同步。

- SyncStep struct**:
  - Execute(ctx *SyncContext) error:
    - 遍历 ctx.DesiredState 中的每一个期望的资源（resourceName, desiredProps）。
    - 对于每一个资源，它需要：
    a.  将 resourceName 记录到 ctx.ManagedResources 中。
    b.  检查该资源是否存在于 worldState 中。
    c.  如果**不存在**，就在 worldState 中创建它，并设置其属性为 desiredProps。
    d.  如果**存在**，就检查其当前属性是否与 desiredProps 完全相同。如果不同，就更新 worldState 中的属性。
      
3. 实现垃圾回收步骤 (GCStep)

这个步骤负责清理所有不该存在的资源。

- GCStep struct**:
  - Execute(ctx *SyncContext) error:
    - 遍历当前 worldState 中的每一个实际存在的资源 (resourceName, _)。
    - 检查 resourceName 是否存在于 ctx.ManagedResources 这个 map 中。
    - 如果**不存在**，说明它是一个“孤儿”资源，应该从 worldState 中删除。
      
4. 组装并运行

在 main 函数中，模拟一个完整的同步周期。

1. 定义初始状态:
  - 初始化 worldState，包含一些需要被更新、一些需要被保留、以及一个需要被删除的资源。
  - 例如：worldState = { "config-A": {"version": "1"}, "config-C": {"data": "stale"} }
2. 定义期望状态:
  - 创建一个 DesiredState map，作为我们同步的目标。
  - 例如：DesiredState = { "config-A": {"version": "2"}, "config-B": {"owner": "jerry"} }
  - 在这个例子中，config-A 需要更新，config-B 需要创建，而 config-C 需要被删除。
3. 创建并运行流水线:
  - 创建一个 Pipeline，其步骤为 &SyncStep{} 和 &GCStep{}。
  - 使用你定义的 DesiredState 初始化一个 SyncContext。
  - 运行流水线。
4. 验证结果:
  - 在流水线运行结束后，打印最终的 worldState。它应该与你定义的 DesiredState 完全一致。
    

---

提示

- 你需要 import "reflect" 来深度比较两个 map (reflect.DeepEqual)，以判断资源属性是否需要更新。
- 这个模式（同步期望的 -> 删除多余的）是 Kubernetes 中 Controller 的核心工作原理。例如，当你把 Deployment 的 replicas 从 5 改为 3，Controller 就会同步这 3 个 Pod，然后把多余的 2 个“垃圾回收”掉。
  
完成这个练习后，你对 step.go 乃至整个 Operator 设计模式的理解，将会达到一个新的高度。祝你编码愉快！

---

package main

import (
        "fmt"
        "reflect"
        "strings"
        "time"
)

// --- 模拟外部世界 ---
// worldState 模拟了集群中的实际资源状态 (e.g., K8s API Server)
var worldState = make(map[string]map[string]string)

// --- 微型框架 ---

// Step 接口定义了一个操作单元
type Step interface {
        Execute(ctx *SyncContext) error
}

// SyncContext 持有流水线运行所需的所有上下文信息
type SyncContext struct {
        // DesiredState 是我们期望达到的最终状态
        DesiredState map[string]map[string]string
        // ManagedResources 用于追踪本次同步中应该存在的资源，以便进行垃圾回收
        ManagedResources map[string]bool
}

// Pipeline 负责按顺序执行一系列步骤
type Pipeline struct {
        steps []Step
}

func NewPipeline(steps ...Step) *Pipeline {
        return &Pipeline{steps: steps}
}

func (p *Pipeline) Run(ctx *SyncContext) error {
        for _, s := range p.steps {
                // 使用反射获取步骤的名称，便于日志观察
                stepName := reflect.TypeOf(s).Elem().Name()
                fmt.Printf("\n--- Running Step: %s ---\n", stepName)
                if err := s.Execute(ctx); err != nil {
                        return fmt.Errorf("pipeline failed at step %s: %w", stepName, err)
                }
        }
        return nil
}

// --- 流水线步骤实现 ---

// SyncStep 负责将当前状态同步到期望状态（创建和更新）
type SyncStep struct{}

func (s *SyncStep) Execute(ctx *SyncContext) error {
        fmt.Println("🎯 Goal: Ensure all desired resources exist and are up-to-date.")

        for name, desiredProps := range ctx.DesiredState {
                // 1. 将资源标记为“受控”，表示它在期望状态中
                ctx.ManagedResources[name] = true
                fmt.Printf("  - Checking resource: %s\n", name)

                currentProps, exists := worldState[name]

                if !exists {
                        // 2. 如果资源不存在，则创建
                        fmt.Printf("    - Status: Not found. ==> CREATING\n")
                        worldState[name] = desiredProps
                        fmt.Printf("    - ✅ Created resource '%s' with props: %v\n", name, desiredProps)
                } else {
                        // 3. 如果资源存在，使用 reflect.DeepEqual 深度比较属性
                        if !reflect.DeepEqual(currentProps, desiredProps) {
                                // 属性不一致，则更新
                                fmt.Printf("    - Status: Outdated. ==> UPDATING\n")
                                fmt.Printf("    - Before: %v\n", currentProps)
                                fmt.Printf("    - After:  %v\n", desiredProps)
                                worldState[name] = desiredProps
                                fmt.Printf("    - ✅ Updated resource '%s'.\n", name)
                        } else {
                                // 属性一致，则跳过
                                fmt.Printf("    - Status: Already in sync. ==> SKIPPING\n")
                        }
                }
        }
        return nil
}

// GCStep (Garbage Collection Step) 负责清理不再需要的资源
type GCStep struct{}

func (s *GCStep) Execute(ctx *SyncContext) error {
        fmt.Println("🎯 Goal: Clean up any resources that are not in the desired state.")

        // 不能在遍历 map 时删除元素，所以先收集要删除的 key
        orphansToDelete := []string{}

        for name := range worldState {
                // 1. 检查真实存在的资源是否在“受控”列表中
                if _, isManaged := ctx.ManagedResources[name]; !isManaged {
                        // 2. 如果不在，说明它是孤儿资源，需要被垃圾回收
                        fmt.Printf("  - Found orphaned resource: '%s'. Marking for deletion.\n", name)
                        orphansToDelete = append(orphansToDelete, name)
                }
        }

        // 3. 执行删除
        for _, name := range orphansToDelete {
                delete(worldState, name)
                fmt.Printf("  - ✅ Deleted resource '%s'.\n", name)
        }

        if len(orphansToDelete) == 0 {
                fmt.Println("  - No orphaned resources found.")
        }

        return nil
}

// --- 主程序 ---

func main() {
        // 1. 定义初始世界状态
        // - config-A: 需要更新
        // - config-C: 需要被删除 (孤儿)
        // - config-D: 已经同步，无需操作
        worldState = map[string]map[string]string{
                "config-A": {"version": "1", "owner": "system"},
                "config-C": {"data": "stale"},
                "config-D": {"status": "ok"},
        }

        // 2. 定义期望达到的最终状态
        // - config-A: 版本更新为 "2"
        // - config-B: 需要被创建
        // - config-D: 保持不变
        desiredState := map[string]map[string]string{
                "config-A": {"version": "2", "owner": "system"},
                "config-B": {"owner": "jerry", "managed-by": "pipeline"},
                "config-D": {"status": "ok"},
        }

        fmt.Println("========= Batch Resource Synchronizer =========")
        printState("Initial World State", worldState)

        // 3. 创建流水线上下文
        syncContext := &SyncContext{
                DesiredState:     desiredState,
                ManagedResources: make(map[string]bool),
        }

        // 4. 创建并运行流水线
        // 流水线由两个核心步骤组成：先同步，后垃圾回收
        pipeline := NewPipeline(&SyncStep{}, &GCStep{})
        err := pipeline.Run(syncContext)
        if err != nil {
                fmt.Printf("\n❌ Pipeline execution failed: %v\n", err)
                return
        }

        fmt.Println("\n✅ Pipeline execution finished successfully!")
        printState("Final World State", worldState)

        // 5. 验证结果
        fmt.Println("\n--- Verification ---")
        if reflect.DeepEqual(desiredState, worldState) {
                fmt.Println("🎉 SUCCESS: Final world state matches the desired state.")
        } else {
                fmt.Println("🔥 FAILURE: Final world state does NOT match the desired state.")
                printState("Expected State", desiredState)
        }
}

// printState 是一个辅助函数，用于美化输出
func printState(title string, state map[string]map[string]string) {
        fmt.Printf("\n----- %s -----\n", title)
        if len(state) == 0 {
                fmt.Println("(empty)")
                return
        }
        for name, props := range state {
                var propStrings []string
                for k, v := range props {
                        propStrings = append(propStrings, fmt.Sprintf("%s=\"%s\"", k, v))
                }
                fmt.Printf("  • %s: { %s }\n", name, strings.Join(propStrings, ", "))
        }
        fmt.Println("--------------------")
}