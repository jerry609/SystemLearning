ç»ƒä¹  4: æ‰¹é‡èµ„æºåŒæ­¥å™¨ (Batch Resource Synchronizer)

ç›®æ ‡:

æ„å»ºä¸€ä¸ªèƒ½å¤ŸåŒæ­¥ä¸€ä¸ª**èµ„æºé›†åˆ**çš„æµæ°´çº¿ã€‚ä½ éœ€è¦å®šä¹‰ä¸€ä¸ªâ€œæœŸæœ›çŠ¶æ€â€çš„èµ„æºæ¸…å•ï¼Œæµæ°´çº¿ä¼šè‡ªåŠ¨æ£€æŸ¥å½“å‰ä¸–ç•Œä¸­çš„æ‰€æœ‰èµ„æºï¼Œç„¶åæ‰§è¡Œå¿…è¦çš„åˆ›å»ºã€æ›´æ–°å’Œ**åˆ é™¤**æ“ä½œï¼Œä»¥ç¡®ä¿çœŸå®ä¸–ç•Œæœ€ç»ˆä¸æœŸæœ›çŠ¶æ€å®Œå…¨ä¸€è‡´ã€‚

è¿™ä¸ªç»ƒä¹ å°†æ˜¯ä¹‹å‰æ‰€æœ‰æ¦‚å¿µçš„é›†å¤§æˆè€…ï¼Œå¹¶è®©ä½ æŒæ¡ï¼š
1. å£°æ˜å¼çŠ¶æ€åŒæ­¥: ä½ åªéœ€å£°æ˜ä¸€ä¸ªæœ€ç»ˆçš„æœŸæœ›çŠ¶æ€ï¼ˆa list of resourcesï¼‰ï¼Œå‰©ä¸‹çš„äº¤ç»™æµæ°´çº¿ã€‚
2. åŠ¨æ€å¾ªç¯ä¸å†³ç­–: åœ¨ä¸€ä¸ªæ­¥éª¤å†…å¾ªç¯å¤„ç†å¤šä¸ªèµ„æºï¼Œå¹¶ä¸ºæ¯ä¸ªèµ„æºåšå‡ºç‹¬ç«‹çš„ Create æˆ– Update å†³å®šã€‚
3. åƒåœ¾å›æ”¶ (Garbage Collection): å®ç°ä¸€ä¸ªæ­¥éª¤ï¼Œç”¨äºåˆ é™¤é‚£äº›â€œä¸åº”è¯¥å­˜åœ¨â€çš„èµ„æºã€‚
4. ç»„åˆä¸é‡ç”¨: ä½ å°†å†æ¬¡çœ‹åˆ°ï¼Œä¹‹å‰åˆ›å»ºçš„ CreateStep å’Œ UpdateStep ç­‰åŸå­æ“ä½œå¯ä»¥è¢«æ–°çš„ã€æ›´å®è§‚çš„æ­¥éª¤ï¼ˆå¦‚ SyncStepï¼‰æ‰€ç¼–æ’å’Œè°ƒç”¨ã€‚
  

---

ä»»åŠ¡è¦æ±‚

1. æ‰©å±• Context

æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ–°çš„ Context æ¥æŒæœ‰æˆ‘ä»¬çš„â€œæœŸæœ›çŠ¶æ€æ¸…å•â€ã€‚

- SyncContext struct**:
  - DesiredState (map[string]map[string]string): æˆ‘ä»¬æœŸæœ›çš„æœ€ç»ˆçŠ¶æ€ã€‚Key æ˜¯èµ„æºåï¼ŒValue æ˜¯è¯¥èµ„æºçš„å±æ€§ã€‚
  - ManagedResources (map[string]bool): ä¸€ä¸ªå†…éƒ¨è·Ÿè¸ªå™¨ã€‚åœ¨åŒæ­¥è¿‡ç¨‹ä¸­ï¼Œæ¯å¤„ç†ä¸€ä¸ªæœŸæœ›çš„èµ„æºï¼Œå°±å°†å…¶åå­—è®°å½•åˆ°è¿™é‡Œã€‚è¿™å¯¹äºåç»­çš„åƒåœ¾å›æ”¶è‡³å…³é‡è¦ã€‚
    
2. å®ç°æ ¸å¿ƒåŒæ­¥æ­¥éª¤ (SyncStep)

è¿™æ˜¯æœ¬æ¬¡ç»ƒä¹ çš„ç»å¯¹æ ¸å¿ƒã€‚è¿™ä¸ªæ­¥éª¤è´Ÿè´£å°† worldState å‘ DesiredState åŒæ­¥ã€‚

- SyncStep struct**:
  - Execute(ctx *SyncContext) error:
    - éå† ctx.DesiredState ä¸­çš„æ¯ä¸€ä¸ªæœŸæœ›çš„èµ„æºï¼ˆresourceName, desiredPropsï¼‰ã€‚
    - å¯¹äºæ¯ä¸€ä¸ªèµ„æºï¼Œå®ƒéœ€è¦ï¼š
    a.  å°† resourceName è®°å½•åˆ° ctx.ManagedResources ä¸­ã€‚
    b.  æ£€æŸ¥è¯¥èµ„æºæ˜¯å¦å­˜åœ¨äº worldState ä¸­ã€‚
    c.  å¦‚æœ**ä¸å­˜åœ¨**ï¼Œå°±åœ¨ worldState ä¸­åˆ›å»ºå®ƒï¼Œå¹¶è®¾ç½®å…¶å±æ€§ä¸º desiredPropsã€‚
    d.  å¦‚æœ**å­˜åœ¨**ï¼Œå°±æ£€æŸ¥å…¶å½“å‰å±æ€§æ˜¯å¦ä¸ desiredProps å®Œå…¨ç›¸åŒã€‚å¦‚æœä¸åŒï¼Œå°±æ›´æ–° worldState ä¸­çš„å±æ€§ã€‚
      
3. å®ç°åƒåœ¾å›æ”¶æ­¥éª¤ (GCStep)

è¿™ä¸ªæ­¥éª¤è´Ÿè´£æ¸…ç†æ‰€æœ‰ä¸è¯¥å­˜åœ¨çš„èµ„æºã€‚

- GCStep struct**:
  - Execute(ctx *SyncContext) error:
    - éå†å½“å‰ worldState ä¸­çš„æ¯ä¸€ä¸ªå®é™…å­˜åœ¨çš„èµ„æº (resourceName, _)ã€‚
    - æ£€æŸ¥ resourceName æ˜¯å¦å­˜åœ¨äº ctx.ManagedResources è¿™ä¸ª map ä¸­ã€‚
    - å¦‚æœ**ä¸å­˜åœ¨**ï¼Œè¯´æ˜å®ƒæ˜¯ä¸€ä¸ªâ€œå­¤å„¿â€èµ„æºï¼Œåº”è¯¥ä» worldState ä¸­åˆ é™¤ã€‚
      
4. ç»„è£…å¹¶è¿è¡Œ

åœ¨ main å‡½æ•°ä¸­ï¼Œæ¨¡æ‹Ÿä¸€ä¸ªå®Œæ•´çš„åŒæ­¥å‘¨æœŸã€‚

1. å®šä¹‰åˆå§‹çŠ¶æ€:
  - åˆå§‹åŒ– worldStateï¼ŒåŒ…å«ä¸€äº›éœ€è¦è¢«æ›´æ–°ã€ä¸€äº›éœ€è¦è¢«ä¿ç•™ã€ä»¥åŠä¸€ä¸ªéœ€è¦è¢«åˆ é™¤çš„èµ„æºã€‚
  - ä¾‹å¦‚ï¼šworldState = { "config-A": {"version": "1"}, "config-C": {"data": "stale"} }
2. å®šä¹‰æœŸæœ›çŠ¶æ€:
  - åˆ›å»ºä¸€ä¸ª DesiredState mapï¼Œä½œä¸ºæˆ‘ä»¬åŒæ­¥çš„ç›®æ ‡ã€‚
  - ä¾‹å¦‚ï¼šDesiredState = { "config-A": {"version": "2"}, "config-B": {"owner": "jerry"} }
  - åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œconfig-A éœ€è¦æ›´æ–°ï¼Œconfig-B éœ€è¦åˆ›å»ºï¼Œè€Œ config-C éœ€è¦è¢«åˆ é™¤ã€‚
3. åˆ›å»ºå¹¶è¿è¡Œæµæ°´çº¿:
  - åˆ›å»ºä¸€ä¸ª Pipelineï¼Œå…¶æ­¥éª¤ä¸º &SyncStep{} å’Œ &GCStep{}ã€‚
  - ä½¿ç”¨ä½ å®šä¹‰çš„ DesiredState åˆå§‹åŒ–ä¸€ä¸ª SyncContextã€‚
  - è¿è¡Œæµæ°´çº¿ã€‚
4. éªŒè¯ç»“æœ:
  - åœ¨æµæ°´çº¿è¿è¡Œç»“æŸåï¼Œæ‰“å°æœ€ç»ˆçš„ worldStateã€‚å®ƒåº”è¯¥ä¸ä½ å®šä¹‰çš„ DesiredState å®Œå…¨ä¸€è‡´ã€‚
    

---

æç¤º

- ä½ éœ€è¦ import "reflect" æ¥æ·±åº¦æ¯”è¾ƒä¸¤ä¸ª map (reflect.DeepEqual)ï¼Œä»¥åˆ¤æ–­èµ„æºå±æ€§æ˜¯å¦éœ€è¦æ›´æ–°ã€‚
- è¿™ä¸ªæ¨¡å¼ï¼ˆåŒæ­¥æœŸæœ›çš„ -> åˆ é™¤å¤šä½™çš„ï¼‰æ˜¯ Kubernetes ä¸­ Controller çš„æ ¸å¿ƒå·¥ä½œåŸç†ã€‚ä¾‹å¦‚ï¼Œå½“ä½ æŠŠ Deployment çš„ replicas ä» 5 æ”¹ä¸º 3ï¼ŒController å°±ä¼šåŒæ­¥è¿™ 3 ä¸ª Podï¼Œç„¶åæŠŠå¤šä½™çš„ 2 ä¸ªâ€œåƒåœ¾å›æ”¶â€æ‰ã€‚
  
å®Œæˆè¿™ä¸ªç»ƒä¹ åï¼Œä½ å¯¹ step.go ä¹ƒè‡³æ•´ä¸ª Operator è®¾è®¡æ¨¡å¼çš„ç†è§£ï¼Œå°†ä¼šè¾¾åˆ°ä¸€ä¸ªæ–°çš„é«˜åº¦ã€‚ç¥ä½ ç¼–ç æ„‰å¿«ï¼

---

package main

import (
        "fmt"
        "reflect"
        "strings"
        "time"
)

// --- æ¨¡æ‹Ÿå¤–éƒ¨ä¸–ç•Œ ---
// worldState æ¨¡æ‹Ÿäº†é›†ç¾¤ä¸­çš„å®é™…èµ„æºçŠ¶æ€ (e.g., K8s API Server)
var worldState = make(map[string]map[string]string)

// --- å¾®å‹æ¡†æ¶ ---

// Step æ¥å£å®šä¹‰äº†ä¸€ä¸ªæ“ä½œå•å…ƒ
type Step interface {
        Execute(ctx *SyncContext) error
}

// SyncContext æŒæœ‰æµæ°´çº¿è¿è¡Œæ‰€éœ€çš„æ‰€æœ‰ä¸Šä¸‹æ–‡ä¿¡æ¯
type SyncContext struct {
        // DesiredState æ˜¯æˆ‘ä»¬æœŸæœ›è¾¾åˆ°çš„æœ€ç»ˆçŠ¶æ€
        DesiredState map[string]map[string]string
        // ManagedResources ç”¨äºè¿½è¸ªæœ¬æ¬¡åŒæ­¥ä¸­åº”è¯¥å­˜åœ¨çš„èµ„æºï¼Œä»¥ä¾¿è¿›è¡Œåƒåœ¾å›æ”¶
        ManagedResources map[string]bool
}

// Pipeline è´Ÿè´£æŒ‰é¡ºåºæ‰§è¡Œä¸€ç³»åˆ—æ­¥éª¤
type Pipeline struct {
        steps []Step
}

func NewPipeline(steps ...Step) *Pipeline {
        return &Pipeline{steps: steps}
}

func (p *Pipeline) Run(ctx *SyncContext) error {
        for _, s := range p.steps {
                // ä½¿ç”¨åå°„è·å–æ­¥éª¤çš„åç§°ï¼Œä¾¿äºæ—¥å¿—è§‚å¯Ÿ
                stepName := reflect.TypeOf(s).Elem().Name()
                fmt.Printf("\n--- Running Step: %s ---\n", stepName)
                if err := s.Execute(ctx); err != nil {
                        return fmt.Errorf("pipeline failed at step %s: %w", stepName, err)
                }
        }
        return nil
}

// --- æµæ°´çº¿æ­¥éª¤å®ç° ---

// SyncStep è´Ÿè´£å°†å½“å‰çŠ¶æ€åŒæ­¥åˆ°æœŸæœ›çŠ¶æ€ï¼ˆåˆ›å»ºå’Œæ›´æ–°ï¼‰
type SyncStep struct{}

func (s *SyncStep) Execute(ctx *SyncContext) error {
        fmt.Println("ğŸ¯ Goal: Ensure all desired resources exist and are up-to-date.")

        for name, desiredProps := range ctx.DesiredState {
                // 1. å°†èµ„æºæ ‡è®°ä¸ºâ€œå—æ§â€ï¼Œè¡¨ç¤ºå®ƒåœ¨æœŸæœ›çŠ¶æ€ä¸­
                ctx.ManagedResources[name] = true
                fmt.Printf("  - Checking resource: %s\n", name)

                currentProps, exists := worldState[name]

                if !exists {
                        // 2. å¦‚æœèµ„æºä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»º
                        fmt.Printf("    - Status: Not found. ==> CREATING\n")
                        worldState[name] = desiredProps
                        fmt.Printf("    - âœ… Created resource '%s' with props: %v\n", name, desiredProps)
                } else {
                        // 3. å¦‚æœèµ„æºå­˜åœ¨ï¼Œä½¿ç”¨ reflect.DeepEqual æ·±åº¦æ¯”è¾ƒå±æ€§
                        if !reflect.DeepEqual(currentProps, desiredProps) {
                                // å±æ€§ä¸ä¸€è‡´ï¼Œåˆ™æ›´æ–°
                                fmt.Printf("    - Status: Outdated. ==> UPDATING\n")
                                fmt.Printf("    - Before: %v\n", currentProps)
                                fmt.Printf("    - After:  %v\n", desiredProps)
                                worldState[name] = desiredProps
                                fmt.Printf("    - âœ… Updated resource '%s'.\n", name)
                        } else {
                                // å±æ€§ä¸€è‡´ï¼Œåˆ™è·³è¿‡
                                fmt.Printf("    - Status: Already in sync. ==> SKIPPING\n")
                        }
                }
        }
        return nil
}

// GCStep (Garbage Collection Step) è´Ÿè´£æ¸…ç†ä¸å†éœ€è¦çš„èµ„æº
type GCStep struct{}

func (s *GCStep) Execute(ctx *SyncContext) error {
        fmt.Println("ğŸ¯ Goal: Clean up any resources that are not in the desired state.")

        // ä¸èƒ½åœ¨éå† map æ—¶åˆ é™¤å…ƒç´ ï¼Œæ‰€ä»¥å…ˆæ”¶é›†è¦åˆ é™¤çš„ key
        orphansToDelete := []string{}

        for name := range worldState {
                // 1. æ£€æŸ¥çœŸå®å­˜åœ¨çš„èµ„æºæ˜¯å¦åœ¨â€œå—æ§â€åˆ—è¡¨ä¸­
                if _, isManaged := ctx.ManagedResources[name]; !isManaged {
                        // 2. å¦‚æœä¸åœ¨ï¼Œè¯´æ˜å®ƒæ˜¯å­¤å„¿èµ„æºï¼Œéœ€è¦è¢«åƒåœ¾å›æ”¶
                        fmt.Printf("  - Found orphaned resource: '%s'. Marking for deletion.\n", name)
                        orphansToDelete = append(orphansToDelete, name)
                }
        }

        // 3. æ‰§è¡Œåˆ é™¤
        for _, name := range orphansToDelete {
                delete(worldState, name)
                fmt.Printf("  - âœ… Deleted resource '%s'.\n", name)
        }

        if len(orphansToDelete) == 0 {
                fmt.Println("  - No orphaned resources found.")
        }

        return nil
}

// --- ä¸»ç¨‹åº ---

func main() {
        // 1. å®šä¹‰åˆå§‹ä¸–ç•ŒçŠ¶æ€
        // - config-A: éœ€è¦æ›´æ–°
        // - config-C: éœ€è¦è¢«åˆ é™¤ (å­¤å„¿)
        // - config-D: å·²ç»åŒæ­¥ï¼Œæ— éœ€æ“ä½œ
        worldState = map[string]map[string]string{
                "config-A": {"version": "1", "owner": "system"},
                "config-C": {"data": "stale"},
                "config-D": {"status": "ok"},
        }

        // 2. å®šä¹‰æœŸæœ›è¾¾åˆ°çš„æœ€ç»ˆçŠ¶æ€
        // - config-A: ç‰ˆæœ¬æ›´æ–°ä¸º "2"
        // - config-B: éœ€è¦è¢«åˆ›å»º
        // - config-D: ä¿æŒä¸å˜
        desiredState := map[string]map[string]string{
                "config-A": {"version": "2", "owner": "system"},
                "config-B": {"owner": "jerry", "managed-by": "pipeline"},
                "config-D": {"status": "ok"},
        }

        fmt.Println("========= Batch Resource Synchronizer =========")
        printState("Initial World State", worldState)

        // 3. åˆ›å»ºæµæ°´çº¿ä¸Šä¸‹æ–‡
        syncContext := &SyncContext{
                DesiredState:     desiredState,
                ManagedResources: make(map[string]bool),
        }

        // 4. åˆ›å»ºå¹¶è¿è¡Œæµæ°´çº¿
        // æµæ°´çº¿ç”±ä¸¤ä¸ªæ ¸å¿ƒæ­¥éª¤ç»„æˆï¼šå…ˆåŒæ­¥ï¼Œååƒåœ¾å›æ”¶
        pipeline := NewPipeline(&SyncStep{}, &GCStep{})
        err := pipeline.Run(syncContext)
        if err != nil {
                fmt.Printf("\nâŒ Pipeline execution failed: %v\n", err)
                return
        }

        fmt.Println("\nâœ… Pipeline execution finished successfully!")
        printState("Final World State", worldState)

        // 5. éªŒè¯ç»“æœ
        fmt.Println("\n--- Verification ---")
        if reflect.DeepEqual(desiredState, worldState) {
                fmt.Println("ğŸ‰ SUCCESS: Final world state matches the desired state.")
        } else {
                fmt.Println("ğŸ”¥ FAILURE: Final world state does NOT match the desired state.")
                printState("Expected State", desiredState)
        }
}

// printState æ˜¯ä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼Œç”¨äºç¾åŒ–è¾“å‡º
func printState(title string, state map[string]map[string]string) {
        fmt.Printf("\n----- %s -----\n", title)
        if len(state) == 0 {
                fmt.Println("(empty)")
                return
        }
        for name, props := range state {
                var propStrings []string
                for k, v := range props {
                        propStrings = append(propStrings, fmt.Sprintf("%s=\"%s\"", k, v))
                }
                fmt.Printf("  â€¢ %s: { %s }\n", name, strings.Join(propStrings, ", "))
        }
        fmt.Println("--------------------")
}