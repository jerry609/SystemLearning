练习 5: 动态工作流 (Dynamic Workflows)

目标:

创建一个能够根据上下文动态选择并执行不同“子流程”的流水线。我们将模拟一个安装程序，它首先检测需要安装的数据库类型（MySQL 或 PostgreSQL），然后执行对应的、完全独立的安装子流程。

这个练习将让你精通：
1. 工作流的封装: 将一组相关的步骤打包成一个可重用的“子流水线”。
2. 动态分发 (Dynamic Dispatch): 创建一个“调度器”步骤，它的唯一职责是根据上下文选择正确的子流水线并执行它。
3. 递归组合: 体会一个 Pipeline 执行一个 Step，而这个 Step 内部又创建并执行了另一个 Pipeline 的递归之美。这正是 step.go 中 Block 函数的精髓。
  

---

任务要求

1. 复用基础结构

我们将再次复用之前练习的 Context, Step 接口, 和 Pipeline 执行器。

- Context: 一个简单的 map[string]string 类型的 Properties 字段就足够了。
- Step: Execute(ctx *Context) error 接口。
- Pipeline: 能够执行 []Step 的 Run 方法。
  
2. 定义“子工作流”

你需要定义两个独立的、可重用的子工作流。在我们的代码中，它们可以被简单地表示为 []Step 切片。

- mysqlWorkflow:
  - 包含 InstallMySQLStep: 打印 "Sub-Workflow: Installing MySQL..."
  - 包含 ConfigureMySQLStep: 打印 "Sub-Workflow: Configuring MySQL with user 'root'..."
- postgresWorkflow:
  - 包含 InstallPostgresStep: 打印 "Sub-Workflow: Installing PostgreSQL..."
  - 包含 ConfigurePostgresStep: 打印 "Sub-Workflow: Configuring PostgreSQL with user 'postgres'..."
    
3. 实现核心的“调度器”步骤 (DispatcherStep)

这是本次练习的绝对核心。这个 Step 就像一个铁路调度员，它本身不干活，只负责把“火车”（Context）引向正确的“轨道”（子工作流）。

- DispatcherStep struct**:
  - 它需要持有一个“工作流注册表”，可以是一个 map[string][]Step。这个 map 的 key 是工作流的名字（如 "mysql"），value 是对应的 []Step 切片。
  - 它还需要一个“选择器”函数 selector func(ctx *Context) string。这个函数负责检查 Context 并返回应该执行哪个工作流的 key。
- Execute(ctx *Context) error:
  1. 调用 selector(ctx) 函数，从上下文中获取决策依据（例如，得到字符串 "mysql"）。
  2. 使用这个 key 从“工作流注册表”中查找对应的子工作流 []Step。
  3. 如果找不到，返回错误。
  4. 如果找到了，**创建一个新的 Pipeline 实例**，并将这个子工作流的步骤传给它。
  5. 执行这个新的子流水线，记得把当前的 ctx 传递给它。
  6. 返回子流水线执行的结果。
    
4. 实现“决策”步骤 (DetectDatabaseTypeStep)

这个步骤在调度器之前运行，它的工作是模拟环境检测，并将决策所需的信息写入 Context。

- DetectDatabaseTypeStep struct**:
  - 可以有一个 dbType 字段，用于配置它要“检测”出的数据库类型。
- Execute(ctx *Context) error:
  - 将 dbType 的值写入 ctx.Properties["database_type"]。
    
5. 组装并运行

在 main 函数中，将所有部分组合成一个完整的、动态的安装流程。

1. 创建子工作流: 定义好 mysqlWorkflow 和 postgresWorkflow 两个 []Step 切片。
2. 创建调度器:
  - 创建一个 DispatcherStep 实例。
  - 为其配置 selector 函数（它应该读取 ctx.Properties["database_type"]）。
  - 为其配置“工作流注册表”，将 "mysql" 指向 mysqlWorkflow，"postgres" 指向 postgresWorkflow。
3. 创建主流水线:
  - 场景一 (安装 MySQL):
    - 主流水线的步骤是：&DetectDatabaseTypeStep{dbType: "mysql"} 和 dispatcher。
    - 运行主流水线，观察是否打印了 MySQL 的安装步骤。
  - 场景二 (安装 PostgreSQL):
    - 主流水线的步骤是：&DetectDatabaseTypeStep{dbType: "postgres"} 和 dispatcher。
    - 运行主流水线，观察是否打印了 PostgreSQL 的安装步骤。
      

---

提示

- 这个模式的强大之处在于 DispatcherStep 和子工作流是完全解耦的。你可以随时增加一个新的 "mongodbWorkflow" 并注册到调度器中，而无需修改调度器或任何其他工作流的代码。
- 注意 DispatcherStep 的 Execute 方法中，它创建并运行了一个**全新的 Pipeline**。这就是“递归组合”的体现。
  
完成这个练习，你将真正领悟到如何通过组合和封装来驾驭复杂性，这也是 Go 语言设计哲学和 step.go 框架的精髓所在。

---
package main

import (
    "context"
    "fmt"
    "log"
    "reflect"
    "time"
)

// --- 1. 核心抽象 (引入 Go 标准库 context) ---

// ReconcileContext 在流水线步骤之间传递数据
type ReconcileContext struct {
    Properties map[string]string
    GoContext  context.Context
}

// NewReconcileContext 创建一个新的上下文
func NewReconcileContext(goCtx context.Context) *ReconcileContext {
    if goCtx == nil {
        goCtx = context.Background()
    }
    return &ReconcileContext{
        Properties: make(map[string]string),
        GoContext:  goCtx,
    }
}

// Step 是流水线中的一个原子操作
type Step interface {
    Execute(ctx *ReconcileContext) error
}

// stepFunc 是一个辅助类型，让普通函数可以实现 Step 接口
type stepFunc func(ctx *ReconcileContext) error

func (f stepFunc) Execute(ctx *ReconcileContext) error {
    return f(ctx)
}

// --- 2. 通用的步骤装饰器 (中间件模式) ---

// Decorator 是一个函数，它接收一个 Step 并返回一个包装后的 Step
type Decorator func(Step) Step

// WithLogging 记录步骤执行信息
func WithLogging() Decorator {
    return func(s Step) Step {
        return stepFunc(func(ctx *ReconcileContext) error {
            stepName := reflect.TypeOf(s).Elem().Name()
            log.Printf("===> EXECUTING: %s", stepName)
            start := time.Now()
            err := s.Execute(ctx)
            duration := time.Since(start)
            if err != nil {
                log.Printf("<=== FAILED: %s (cost: %v). Error: %v", stepName, duration, err)
            } else {
                log.Printf("<=== FINISHED: %s (cost: %v)", stepName, duration)
            }
            return err
        })
    }
}

// WithTimeout 为步骤设置超时
func WithTimeout(timeout time.Duration) Decorator {
    return func(s Step) Step {
        return stepFunc(func(ctx *ReconcileContext) error {
            stepName := reflect.TypeOf(s).Elem().Name()
            // 创建带超时的子 context
            childCtx, cancel := context.WithTimeout(ctx.GoContext, timeout)
            defer cancel()

            // 更新 ReconcileContext 中的 GoContext
            ctx.GoContext = childCtx

            // 使用 channel 来监听步骤执行结果
            done := make(chan error, 1)
            go func() {
                done <- s.Execute(ctx)
            }()

            // 等待执行完成或超时
            select {
            case <-childCtx.Done():
                return fmt.Errorf("step %s timed out after %v", stepName, timeout)
            case err := <-done:
                return err
            }
        })
    }
}

// Chain 将多个 Decorator 应用到一个 Step 上
func Chain(s Step, decorators ...Decorator) Step {
    wrapped := s
    for i := len(decorators) - 1; i >= 0; i-- {
        wrapped = decorators[i](wrapped)
    }
    return wrapped
}

// --- 3. 使用 Fluent API 构建流水线 ---

type Pipeline struct {
    steps []Step
}

func NewPipeline() *Pipeline {
    return &Pipeline{steps: []Step{}}
}

func (p *Pipeline) Add(steps ...Step) *Pipeline {
    p.steps = append(p.steps, steps...)
    return p
}

func (p *Pipeline) Run(ctx *ReconcileContext) error {
    for _, step := range p.steps {
        // 检查 GoContext 是否已取消
        select {
        case <-ctx.GoContext.Done():
            log.Printf("Pipeline cancelled. Reason: %v", ctx.GoContext.Err())
            return ctx.GoContext.Err()
        default:
            // 继续执行
        }

        if err := step.Execute(ctx); err != nil {
            return err
        }
    }
    return nil
}

// --- 4. 业务步骤实现 ---

type InstallMySQLStep struct{}

func (s *InstallMySQLStep) Execute(_ *ReconcileContext) error {
    fmt.Println("     Sub-Workflow: Installing MySQL...")
    return nil
}

// TimedStep 模拟一个耗时操作
type TimedStep struct {
    Duration time.Duration
}

func (s *TimedStep) Execute(ctx *ReconcileContext) error {
    fmt.Printf("     Sub-Workflow: Starting a task that takes %v...\n", s.Duration)
    select {
    case <-time.After(s.Duration):
        fmt.Println("     Sub-Workflow: Task finished.")
        return nil
    case <-ctx.GoContext.Done():
        fmt.Printf("     Sub-Workflow: Task cancelled! Reason: %v\n", ctx.GoContext.Err())
        return ctx.GoContext.Err()
    }
}

type InstallPostgresStep struct{}

func (s *InstallPostgresStep) Execute(_ *ReconcileContext) error {
    fmt.Println("     Sub-Workflow: Installing PostgreSQL...")
    return nil
}

type DetectDatabaseTypeStep struct {
    dbType string
}

func (s *DetectDatabaseTypeStep) Execute(ctx *ReconcileContext) error {
    fmt.Printf("     Detecting database type, setting to: %s\n", s.dbType)
    ctx.Properties["database_type"] = s.dbType
    return nil
}

type DispatcherStep struct {
    workflowRegistry map[string]*Pipeline
    selector         func(ctx *ReconcileContext) string
}

func NewDispatcherStep(registry map[string]*Pipeline, selector func(ctx *ReconcileContext) string) *DispatcherStep {
    return &DispatcherStep{
        workflowRegistry: registry,
        selector:         selector,
    }
}

func (s *DispatcherStep) Execute(ctx *ReconcileContext) error {
    workflowKey := s.selector(ctx)
    fmt.Printf("     Dispatcher decided to run workflow: '%s'\n", workflowKey)

    subPipeline, ok := s.workflowRegistry[workflowKey]
    if !ok {
        return fmt.Errorf("no workflow found for key: %s", workflowKey)
    }

    fmt.Println("     Creating and running a sub-pipeline...")
    err := subPipeline.Run(ctx)
    if err == nil {
        fmt.Println("     ...Sub-pipeline finished successfully.")
    }
    return err
}

// --- 5. 组装并运行 ---

func main() {
    logDecorator := WithLogging()

    // 1. 创建子工作流
    mysqlWorkflow := NewPipeline().Add(
        Chain(&InstallMySQLStep{}, logDecorator),
    )

    postgresWorkflow := NewPipeline().Add(
        Chain(&InstallPostgresStep{}, logDecorator),
        // 演示超时：这个步骤需要3秒，但我们设置了2秒超时
        Chain(&TimedStep{Duration: 3 * time.Second}, logDecorator, WithTimeout(2*time.Second)),
    )

    // 2. 创建调度器
    workflowRegistry := map[string]*Pipeline{
        "mysql":    mysqlWorkflow,
        "postgres": postgresWorkflow,
    }
    selector := func(ctx *ReconcileContext) string { return ctx.Properties["database_type"] }
    dispatcher := Chain(NewDispatcherStep(workflowRegistry, selector), logDecorator)

    // 3. 运行场景
    runScenario("Scenario 1: Installing MySQL", "mysql", dispatcher)
    runScenario("Scenario 2: Testing Timeout in PostgreSQL workflow", "postgres", dispatcher)
}

func runScenario(name, dbType string, dispatcher Step) {
    fmt.Printf("\n==========================================\n")
    fmt.Printf("=== %s ===\n", name)
    fmt.Printf("==========================================\n")

    mainPipeline := NewPipeline().Add(
        Chain(&DetectDatabaseTypeStep{dbType: dbType}, WithLogging()),
        dispatcher,
    )

    // 使用标准库 context
    ctx := NewReconcileContext(context.Background())
    if err := mainPipeline.Run(ctx); err != nil {
        log.Printf("Main pipeline finished with error: %v", err)
    } else {
        log.Println("Main pipeline finished successfully.")
    }
}
