练习任务：构建一个“数据清洗”流水线

想象一下，你需要处理一个字符串列表，对它们进行一系列的清洗和转换。我们将构建一个可配置的、由多个步骤组成的流水线来完成这个任务。

最终目标：写一个 Go 程序，它定义一个“数据处理流水线”，可以按顺序执行以下操作：

1. 过滤 (Filter)：移除列表中长度小于 N 的字符串。
2. 转换 (Transform)：将所有字符串转换为大写。
3. 验证 (Validate)：检查是否有字符串包含 "badword"，如果包含则中止流水线并返回错误。
4. 打印 (Print)：将最终结果打印到控制台。
  
关键要求：你需要模仿 step.go 的模式，将每个操作都封装成一个独立的、可复用的 Step，然后将它们“编排”到一个 Pipeline 中执行。


---

第一步：定义你的“微型框架”

在开始写具体逻辑前，先在 pipeline.go 文件中定义好我们的“微型 step.go 框架”。

// pipeline.go

package main

import "fmt"

// 1. 定义 "步骤" 的核心行为 (类似 ExecuteFunc)
type StepFunc func(data []string) ([]string, error)

// 2. 定义 "步骤" 接口 (类似 Step 接口)
type Step interface {
    Name() string
    Execute(data []string) ([]string, error)
}

// 3. 定义一个通用的步骤实现 (类似 step 结构体)
type simpleStep struct {
    name string
    f    StepFunc
}

func (s *simpleStep) Name() string {
    return s.name
}

func (s *simpleStep) Execute(data []string) ([]string, error) {
    fmt.Printf("--- Executing Step: %s ---\n", s.name)
    return s.f(data)
}

// NewStep 是一个辅助函数，用于快速创建步骤 (类似 NewStep)
func NewStep(name string, f StepFunc) Step {
    return &simpleStep{
        name: name,
        f:    f,
    }
}

// 4. 定义 "流水线" (类似 Task 结构体)
type Pipeline struct {
    steps []Step
}

// NewPipeline 用于创建一个新的流水线
func NewPipeline(steps ...Step) *Pipeline {
    return &Pipeline{
        steps: steps,
    }
}

// Run 方法负责按顺序执行所有步骤 (类似 Flow 执行器)
func (p *Pipeline) Run(initialData []string) ([]string, error) {
    data := initialData
    var err error

    for _, step := range p.steps {
        data, err = step.Execute(data)
        if err != nil {
            // 如果任何一个步骤出错，立即中止
            return nil, fmt.Errorf("pipeline failed at step '%s': %w", step.Name(), err)
        }
    }

    return data, nil
}

你的任务 (1): 将上面的代码复制到一个 pipeline.go 文件中。花点时间阅读并理解每个部分是如何与 step.go 中的概念对应的。


---

第二步：实现具体的处理步骤

现在，在 main.go 文件中，利用上面的框架来实现我们需要的具体逻辑。

你的任务 (2):

1. 创建 main.go 文件**。
2. 实现 Filter 逻辑**：
  - 创建一个函数 NewFilterStep(minLength int) Step。
  - 这个函数内部需要使用闭包来“记住” minLength。
  - 它返回一个 Step，其 Execute 逻辑是遍历数据，只保留长度大于等于 minLength 的字符串。
    
3. 实现 Transform 逻辑**：
  - 创建一个 ToUpperStep Step 变量。
  - 它的逻辑是将所有字符串转换为大写。
    
4. 实现 Validate 逻辑**：
  - 创建一个 NewValidateStep(word string) Step 函数。
  - 它也使用闭包来记住要检查的 word。
  - 它的逻辑是检查是否有字符串包含 word，如果有，就返回一个 error。
    
5. 实现 Print 逻辑**：
  - 创建一个 PrintStep Step 变量，它的逻辑是遍历并打印最终的字符串列表。
    

---

第三步：组装并运行你的流水线

所有零件都准备好了，现在在 main 函数中把它们组装起来！

你的任务 (3):

在 main 函数中：
1. 定义一个初始的字符串列表，例如 []string{"hello", "world", "go", "is", "awesome", "a badword here"}。
2. 使用你创建的 New...Step 函数和变量，来实例化所有需要的步骤。
3. 将这些步骤传入 NewPipeline，创建一个流水线实例。
4. 调用流水线的 Run 方法，并处理可能返回的错误。
  

---

提示与最终效果

你的 main.go 文件结构可能看起来像这样：

// main.go
package main

import (
        "errors"
        "fmt"
        "strings"
)

// --- 在这里实现你的 Step 创建函数 ---

// 例如: NewFilterStep
func NewFilterStep(minLength int) Step {
    // ... 你的实现 ...
    // 提示: 返回 NewStep(...)
}

// ... 其他 Step 的实现 ...


func main() {
    // 1. 初始数据
    rawData := []string{"hello", "world", "go", "is", "awesome", "a badword here"}
    fmt.Println("Initial data:", rawData)

    // 2. 实例化所有步骤
    filterStep := NewFilterStep(4)
    // ... 实例化其他步骤 ...
    
    // 3. 组装流水线
    pipeline := NewPipeline(
        filterStep,
        // ... 添加其他步骤 ...
    )

    // 4. 运行
    result, err := pipeline.Run(rawData)
    if err != nil {
        fmt.Println("\nPipeline stopped with error:", err)
        return
    }

    fmt.Println("\nPipeline finished successfully!")
    fmt.Println("Final data:", result)
}

当你成功完成后，尝试修改初始数据或步骤的参数（比如 minLength），看看流水线是否如预期那样工作。特别是当你包含 "badword" 时，程序应该会提前中止并打印错误。

这个练习将让你深刻体会到如何将复杂的流程拆解成独立的、可测试的单元，并通过一个统一的框架将它们灵活地组合在一起。祝你编码愉快！


---
参考答案
package main

import (
        "errors"
        "fmt"
        "strings"
)

// NewFilterStep 创建一个过滤步骤，使用闭包捕获 minLength
func NewFilterStep(minLength int) Step {
        return NewStep(
                fmt.Sprintf("Filter(minLen=%d)", minLength),
                func(data []string) ([]string, error) {
                        var filtered []string
                        for _, s := range data {
                                if len(s) >= minLength {
                                        filtered = append(filtered, s)
                                }
                        }
                        fmt.Printf("    Input: %v, Output: %v\n", data, filtered)
                        return filtered, nil
                },
        )
}

// ToUpperStep 是一个转换步骤，将所有字符串转为大写
var ToUpperStep = NewStep(
        "Transform(ToUpper)",
        func(data []string) ([]string, error) {
                var transformed []string
                for _, s := range data {
                        transformed = append(transformed, strings.ToUpper(s))
                }
                fmt.Printf("    Input: %v, Output: %v\n", data, transformed)
                return transformed, nil
        },
)

// NewValidateStep 创建一个验证步骤，使用闭包捕获 forbiddenWord
func NewValidateStep(forbiddenWord string) Step {
        return NewStep(
                fmt.Sprintf("Validate(no '%s')", forbiddenWord),
                func(data []string) ([]string, error) {
                        for _, s := range data {
                                if strings.Contains(strings.ToLower(s), forbiddenWord) {
                                        err := errors.New("found forbidden word")
                                        fmt.Printf("    Validation failed for input: %v, Word: '%s'\n", s, forbiddenWord)
                                        return nil, err
                                }
                        }
                        fmt.Printf("    Validation passed for input: %v\n", data)
                        return data, nil // 验证通过，原样返回数据
                },
        )
}

// PrintStep 是一个打印步骤
var PrintStep = NewStep(
        "Print",
        func(data []string) ([]string, error) {
                fmt.Println("    Final result to print:", data)
                return data, nil // 打印步骤不修改数据
        },
)

func main() {
        // --- 场景一：流水线成功 ---
        fmt.Println("========= SCENARIO 1: SUCCESS =========")
        rawDataSuccess := []string{"hello", "world", "go", "is", "awesome"}
        fmt.Println("Initial data:", rawDataSuccess)

        pipelineSuccess := NewPipeline(
                NewFilterStep(4),
                ToUpperStep,
                NewValidateStep("badword"),
                PrintStep,
        )

        result, err := pipelineSuccess.Run(rawDataSuccess)
        if err != nil {
                fmt.Println("\nPipeline stopped with error:", err)
        } else {
                fmt.Println("\nPipeline finished successfully!")
                fmt.Println("Final data:", result)
        }

        fmt.Println("\n\n========= SCENARIO 2: FAILURE =========")
        // --- 场景二：流水线因验证失败而中止 ---
        rawDataFailure := []string{"hello", "world", "go", "is", "a badword here"}
        fmt.Println("Initial data:", rawDataFailure)

        pipelineFailure := NewPipeline(
                NewFilterStep(3),
                ToUpperStep,
                NewValidateStep("badword"),
                PrintStep, // 这个步骤将不会被执行
        )

        result, err = pipelineFailure.Run(rawDataFailure)
        if err != nil {
                fmt.Println("\nPipeline stopped with error:", err)
        } else {
                fmt.Println("\nPipeline finished successfully!")
                fmt.Println("Final data:", result)
        }
}