练习 2: 模拟资源部署器 (Resource Provisioner)

目标:

创建一个微型框架来模拟资源的部署流程。这个流程需要检查一个资源（比如一个配置文件）是否存在。如果不存在，就创建它；如果已存在，就更新它。最后，无论创建还是更新，都需要验证资源是否处于健康状态。

这个练习将让你体验到：
1. 带状态的步骤：步骤之间需要通过一个共享的 Context 来传递信息（例如，资源是否存在）。
2. 条件分支：实现一个类似 step.go 中 When 或 Branch 的核心功能，根据 Context 中的状态来决定执行哪个步骤。
3. 闭包的实际应用：再次使用闭包来创建带有配置的、可复用的步骤。
  

---

任务要求

1. 定义 Context 和 Step

首先，我们需要一个 Context 来在步骤之间传递状态，以及一个新的 Step 接口。

- Context struct:
  - ResourceName (string): 我们要操作的资源的名字。
  - Exists (bool): 一个标志位，表示资源当前是否存在。
  - Properties (map[string]string): 模拟资源的内容或属性。
- Step interface:
  - Execute(ctx *Context) error: 每个步骤接收一个指向 Context 的指针，执行操作，并可能修改它。
    
2. 模拟外部环境

为了让我们的模拟更真实，我们用一个全局的 map 来代表我们正在操作的外部系统（例如，文件系统、数据库、K8s API Server 等）。

// a global map to simulate the real world state
var worldState = make(map[string]map[string]string)

3. 实现基础步骤

你需要实现以下几个 Step：

- CheckStep:
  - 功能：检查 worldState 中是否存在 ctx.ResourceName 对应的资源。
  - 逻辑：如果存在，设置 ctx.Exists = true 和 ctx.Properties；如果不存在，设置 ctx.Exists = false。
- CreateStep:
  - 功能：模拟创建资源。
  - 逻辑：在 worldState 中创建一个新的条目。为了让它更有趣，这个步骤应该接收一个 initialProperties map，并使用闭包来捕获它。
- UpdateStep:
  - 功能：模拟更新资源。
  - 逻辑：修改 worldState 中已有条目的内容。同样，使用闭包来传入要更新的 newProperties。
- VerifyStep:
  - 功能：验证资源是否处于期望的状态。
  - 逻辑：检查 worldState 中资源的的某个属性是否等于期望的值。使用闭包来传入 expectedProperty 和 expectedValue。
    
4. 实现核心流程控制函数 Branch

这是本次练习的核心！你需要创建一个高阶函数，它根据一个条件函数来决定执行两个分支中的哪一个。

- 函数签名: func Branch(condition func(ctx *Context) bool, trueStep, falseStep Step) Step
- 逻辑:
  - 这个函数本身会返回一个**新的 Step**。
  - 当这个返回的 Step 被执行时，它会首先调用 condition(ctx)。
  - 如果条件为 true，它就执行 trueStep。
  - 如果条件为 false，它就执行 falseStep。
    
5. 组装并运行

在 main 函数中，将以上所有部分组装成一个完整的部署流水线。

1. 创建一个 Pipeline（你可以复用上一个练习的 Pipeline，但需要修改 Run 方法来传递 Context）。
2. 定义一个 resourceName。
3. 编排你的步骤：
  - 第一步总是 CheckStep。
  - 第二步使用 Branch 函数：
    - condition 应该是 func(ctx *Context) bool { return ctx.Exists }。
    - trueStep 应该是 UpdateStep。
    - falseStep 应该是 CreateStep。
  - 第三步是 VerifyStep。
4. 运行两次流水线：
  - 第一次运行: worldState 是空的，应该会触发 "Create" 流程。
  - 第二次运行: worldState 中已经有了资源，应该会触发 "Update" 流程。
    

---

提示

- Branch 函数返回的 Step 的 Execute 方法是闭包强大威力的完美展示。它 "记住" 了 condition, trueStep, 和 falseStep。
- 注意 Context 是一个指针，这样每个步骤对它的修改才能被后续步骤看到。
- 这个模式（Check -> Branch[Update/Create] -> Verify）是 Kubernetes Operator 中最常见、最核心的协调逻辑。
  
祝你好运！这个练习比上一个更有挑战性，但完成后你对 step.go 的设计思想会有更深刻的理解。如果遇到困难，随时可以问我。

---
stepFunc(func(...) { ... }) 这段代码的完整含义是：
1. 创建一个匿名函数（它是一个闭包）。
2. 将这个匿名函数的值强制类型转换为 stepFunc 类型。
3. 因为 stepFunc 类型已经实现了 Step 接口，所以这个转换后的值现在是一个合法的 Step。

package main

import (
        "errors"
        "fmt"
        "reflect"
)

// worldState 模拟了外部的真实世界（如 K8s API Server、文件系统等）
// Key 是资源名称，Value 是资源的属性
var worldState = make(map[string]map[string]string)

// Context 在流水线的各个步骤之间传递状态
type Context struct {
        ResourceName string
        Exists       bool
        Properties   map[string]string
}

// Step 定义了流水线中每个步骤的接口
type Step interface {
        Execute(ctx *Context) error
}

// --- 基础步骤实现 ---

// CheckStep 检查资源是否存在于 worldState 中
type CheckStep struct{}

func (s *CheckStep) Execute(ctx *Context) error {
        fmt.Printf("--- [Check] Checking existence of '%s' ---\n", ctx.ResourceName)
        properties, ok := worldState[ctx.ResourceName]
        if ok {
                fmt.Printf("    => Found! Resource exists.\n")
                ctx.Exists = true
                ctx.Properties = properties
        } else {
                fmt.Printf("    => Not Found! Resource does not exist.\n")
                ctx.Exists = false
        }
        return nil
}

// --- 使用闭包创建可配置的步骤 ---

// stepFunc 是一个辅助类型，让普通函数可以实现 Step 接口
type stepFunc func(ctx *Context) error

func (f stepFunc) Execute(ctx *Context) error {
        return f(ctx)
}

// NewCreateStep 创建一个 "创建" 步骤，通过闭包捕获初始属性
func NewCreateStep(initialProperties map[string]string) Step {
        return stepFunc(func(ctx *Context) error {
                fmt.Printf("--- [Create] Creating resource '%s' ---\n", ctx.ResourceName)
                if ctx.Exists {
                        return errors.New("cannot create resource that already exists")
                }
                worldState[ctx.ResourceName] = initialProperties
                ctx.Properties = initialProperties
                ctx.Exists = true
                fmt.Printf("    => Created with properties: %v\n", initialProperties)
                return nil
        })
}

// NewUpdateStep 创建一个 "更新" 步骤，通过闭包捕获要更新的属性
func NewUpdateStep(newProperties map[string]string) Step {
        return stepFunc(func(ctx *Context) error {
                fmt.Printf("--- [Update] Updating resource '%s' ---\n", ctx.ResourceName)
                if !ctx.Exists {
                        return errors.New("cannot update resource that does not exist")
                }
                for k, v := range newProperties {
                        worldState[ctx.ResourceName][k] = v
                }
                ctx.Properties = worldState[ctx.ResourceName]
                fmt.Printf("    => Updated. New properties: %v\n", ctx.Properties)
                return nil
        })
}

// NewVerifyStep 创建一个 "验证" 步骤，通过闭包捕获期望的属性和值
func NewVerifyStep(expectedProperty, expectedValue string) Step {
        return stepFunc(func(ctx *Context) error {
                fmt.Printf("--- [Verify] Verifying property '%s'=='%s' ---\n", expectedProperty, expectedValue)
                currentValue, ok := worldState[ctx.ResourceName][expectedProperty]
                if !ok {
                        return fmt.Errorf("verification failed: property '%s' not found", expectedProperty)
                }
                if currentValue != expectedValue {
                        return fmt.Errorf("verification failed: expected '%s', but got '%s'", expectedValue, currentValue)
                }
                fmt.Printf("    => Success! Property is correct.\n")
                return nil
        })
}

// --- 核心流程控制 ---

// Branch 是一个高阶函数，它返回一个新的 Step
// 这个新的 Step 根据条件函数的布尔结果，来决定执行 trueStep 还是 falseStep
func Branch(condition func(ctx *Context) bool, trueStep, falseStep Step) Step {
        return stepFunc(func(ctx *Context) error {
                if condition(ctx) {
                        fmt.Println("--- [Branch] Condition is true, executing 'true' branch ---")
                        return trueStep.Execute(ctx)
                }
                fmt.Println("--- [Branch] Condition is false, executing 'false' branch ---")
                return falseStep.Execute(ctx)
        })
}

// --- 流水线执行器 ---

type Pipeline struct {
        steps []Step
}

func NewPipeline(steps ...Step) *Pipeline {
        return &Pipeline{steps: steps}
}

func (p *Pipeline) Run(ctx *Context) error {
        for _, step := range p.steps {
                err := step.Execute(ctx)
                if err != nil {
                        // 使用 reflect 来获取具体步骤的类型名，便于调试
                        stepType := reflect.TypeOf(step).String()
                        return fmt.Errorf("pipeline failed at step %s: %w", stepType, err)
                }
        }
        return nil
}

// --- 主函数：组装和运行 ---

func main() {
        resourceName := "my-config.yaml"

        // 编排流水线
        // 这是一个非常典型的 Operator 协调逻辑：
        // 1. 检查资源现状 (Check)
        // 2. 如果存在则更新，如果不存在则创建 (Branch)
        // 3. 验证最终状态是否符合预期 (Verify)
        provisionerPipeline := NewPipeline(
                &CheckStep{},
                Branch(
                        func(ctx *Context) bool { return ctx.Exists }, // 条件：资源是否存在？
                        NewUpdateStep(map[string]string{"version": "2", "author": "admin"}), // True: 更新
                        NewCreateStep(map[string]string{"version": "1"}),                   // False: 创建
                ),
                NewVerifyStep("version", "2"), // 最终状态验证
        )

        // --- 场景一：首次部署，资源不存在 ---
        fmt.Println("========= SCENARIO 1: DEPLOY (Resource does not exist) =========")
        ctx1 := &Context{ResourceName: resourceName}
        err := provisionerPipeline.Run(ctx1)
        if err != nil {
                fmt.Printf("\nPipeline failed: %v\n", err)
        } else {
                fmt.Println("\nPipeline finished successfully!")
        }
        fmt.Printf("Final world state: %v\n", worldState)

        // --- 场景二：再次部署，资源已存在 ---
        // 注意：我们故意将 version 设置为 "1"，让流水线去更新它
        worldState[resourceName] = map[string]string{"version": "1"}
        fmt.Println("\n\n========= SCENARIO 2: REDEPLOY (Resource already exists) =========")
        ctx2 := &Context{ResourceName: resourceName}
        err = provisionerPipeline.Run(ctx2)
        if err != nil {
                fmt.Printf("\nPipeline failed: %v\n", err)
        } else {
                fmt.Println("\nPipeline finished successfully!")
        }
        fmt.Printf("Final world state: %v\n", worldState)
}