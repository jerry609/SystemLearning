目标:

在练习 2 的基础上，为我们的部署器增加弹性。我们将创建一个可以重试的步骤包装器（Wrapper），并模拟一个可能会暂时失败的验证步骤。

这个练习将让你掌握：
1. 高阶函数作为装饰器 (Decorator): 创建一个 WithRetries 函数，它接收一个 Step，并返回一个增强了重试能力的新 Step。
2. 处理暂时性错误: 模拟并处理那些在重试后可能会成功的错误。
3. 有状态的步骤: 创建一个内部状态会变化的 Step，以模拟不稳定的行为。
  

---

任务要求

1. 复用基础结构

你可以完全复用练习 2 中的 Context, Step 接口, Pipeline, CheckStep, CreateStep, UpdateStep 和 Branch 函数。我们的目标是在此基础上进行扩展。

2. 创建一个“不稳定的”步骤 (FlakyStep)

你需要实现一个新的 Step，它会模拟一个不稳定的操作，比如一个需要时间预热的健康检查。

- FlakyVerifyStep struct**:
  - 它需要一个内部计数器，比如 attemptsNeeded (int)，表示它需要被调用多少次才能成功。
  - Execute(ctx *Context) error:
    - 每次被调用时，它将内部计数器减 1。
    - 如果计数器大于 0，它就打印一条“验证失败，仍在等待...”的消息，并返回一个错误（例如 errors.New("resource not ready yet")）。
    - 如果计数器等于或小于 0，它就打印“验证成功！”并返回 nil。
      
3. 实现核心的 WithRetries 装饰器

这是本次练习的核心。你需要创建一个高阶函数，它像一个装饰器一样包装任何 Step，为它添加重试逻辑。

- 函数签名: func WithRetries(maxAttempts int, delay time.Duration, stepToRetry Step) Step
- 逻辑:
  - 这个函数返回一个**新的 Step**。
  - 当这个返回的 Step 被执行时，它会启动一个循环，最多尝试 maxAttempts 次。
  - 在循环中：
    - 它调用被包装的 stepToRetry.Execute(ctx)。
    - 如果 Execute 返回 nil (成功)，循环立即结束，WithRetries 这个步骤也成功返回 nil。
    - 如果 Execute 返回错误，它会打印一条重试信息，等待 delay 指定的时间，然后继续下一次循环。
  - 如果循环 maxAttempts 次后仍然失败，WithRetries 步骤最终返回它收到的最后一个错误。
    
4. 组装并运行

在 main 函数中，将所有部分组装起来。

1. 创建一个 Pipeline。
2. 编排你的步骤：
  - 第一步：CheckStep。
  - 第二步：Branch (用于创建或更新)。
  - 第三步：**使用 WithRetries 包装 FlakyVerifyStep**。
    - 例如：WithRetries(3, 1*time.Second, &FlakyVerifyStep{attemptsNeeded: 2})。这意味着最多重试 3 次，每次间隔 1 秒，而去验证的那个步骤本身需要被调用 2 次才能成功。
3. 运行流水线，并观察输出。你应该能清晰地看到 WithRetries 装饰器是如何工作的：它会调用 FlakyVerifyStep，第一次失败，等待，第二次调用，成功，然后整个流水线继续。
  

---

提示

- 你需要 import "time"。
- FlakyVerifyStep 的 Execute 方法需要一个指针接收者 (func (s *FlakyVerifyStep) Execute(...))，这样它才能修改自己的内部计数器 attemptsNeeded。如果用值接收者，每次调用看到的都是初始值。
- WithRetries 函数返回的那个 Step 的 Execute 方法，是一个完美的闭包应用，它捕获并“记住”了 maxAttempts, delay, 和 stepToRetry。
  
这个练习非常贴近生产环境中的 Operator 代码。完成它，你对如何构建健壮、有弹性的自动化逻辑的理解将更上一层楼。

---
package main

import (
    "errors"
    "fmt"
    "reflect"
    "time"
)

// worldState 模拟了外部的真实世界（如 K8s API Server、文件系统等）
// Key 是资源名称，Value 是资源的属性
var worldState = make(map[string]map[string]string)

// Context 在流水线的各个步骤之间传递状态
type Context struct {
    ResourceName string
    Exists       bool
    Properties   map[string]string
}

// Step 定义了流水线中每个步骤的接口
type Step interface {
    Execute(ctx *Context) error
}
// 新增：Step 工厂函数类型，便于在分支中延迟创建具体 Step
type StepFactory func() Step

// --- 基础步骤实现 ---

// CheckStep 检查资源是否存在于 worldState 中
type CheckStep struct{}

func (s *CheckStep) Execute(ctx *Context) error {
    fmt.Printf("--- [Check] Checking existence of '%s' ---\n", ctx.ResourceName)
    properties, ok := worldState[ctx.ResourceName]
    if ok {
        fmt.Printf("    => Found! Resource exists.\n")
        ctx.Exists = true
        ctx.Properties = properties
    } else {
        fmt.Printf("    => Not Found! Resource does not exist.\n")
        ctx.Exists = false
    }
    return nil
}

// --- 使用闭包创建可配置的步骤 ---

// stepFunc 是一个辅助类型，让普通函数可以实现 Step 接口
type stepFunc func(ctx *Context) error

func (f stepFunc) Execute(ctx *Context) error {
    return f(ctx)
}

// NewCreateStep 创建一个 "创建" 步骤，通过闭包捕获初始属性
func NewCreateStep(initialProperties map[string]string) Step {
    return stepFunc(func(ctx *Context) error {
        fmt.Printf("--- [Create] Creating resource '%s' ---\n", ctx.ResourceName)
        if ctx.Exists {
            return errors.New("cannot create resource that already exists")
        }
        worldState[ctx.ResourceName] = initialProperties
        ctx.Properties = initialProperties
        ctx.Exists = true
        fmt.Printf("    => Created with properties: %v\n", initialProperties)
        return nil
    })
}

// NewUpdateStep 创建一个 "更新" 步骤，通过闭包捕获要更新的属性
func NewUpdateStep(newProperties map[string]string) Step {
    return stepFunc(func(ctx *Context) error {
        fmt.Printf("--- [Update] Updating resource '%s' ---\n", ctx.ResourceName)
        if !ctx.Exists {
            return errors.New("cannot update resource that does not exist")
        }
        for k, v := range newProperties {
            worldState[ctx.ResourceName][k] = v
        }
        ctx.Properties = worldState[ctx.ResourceName]
        fmt.Printf("    => Updated. New properties: %v\n", ctx.Properties)
        return nil
    })
}

// --- 有状态且不稳定的验证步骤 ---

// FlakyVerifyStep 模拟一个需要多次调用才能成功的验证步骤
// 例如：服务刚启动需要预热，第一次检查未就绪，稍后再试就会成功
// attemptsNeeded 表示还需要调用多少次才会成功
// 注意：使用指针接收者以便修改内部状态

type FlakyVerifyStep struct {
    attemptsNeeded int
}

func (s *FlakyVerifyStep) Execute(ctx *Context) error {
    s.attemptsNeeded--
    if s.attemptsNeeded > 0 {
        fmt.Println("--- [Verify] 验证失败，仍在等待...")
        return errors.New("resource not ready yet")
    }
    fmt.Println("--- [Verify] 验证成功！")
    return nil
}

// --- Branch 条件分支 ---

// Branch 是一个高阶函数，它返回一个新的 Step
// 这个新的 Step 根据条件函数的布尔结果，来决定执行 trueFactory 或 falseFactory 生产出的具体步骤
func Branch(condition func(ctx *Context) bool, trueFactory, falseFactory StepFactory) Step {
    return stepFunc(func(ctx *Context) error {
        if condition(ctx) {
            fmt.Println("--- [Branch] Condition is true, executing 'true' branch ---")
            return trueFactory().Execute(ctx)
        }
        fmt.Println("--- [Branch] Condition is false, executing 'false' branch ---")
        return falseFactory().Execute(ctx)
    })
}

// --- WithRetries 装饰器 ---

// WithRetries 返回一个带有重试逻辑的新 Step，最多尝试 maxAttempts 次，每次间隔 delay
func WithRetries(maxAttempts int, delay time.Duration, stepToRetry Step) Step {
    return stepFunc(func(ctx *Context) error {
        var lastErr error
        for attempt := 1; attempt <= maxAttempts; attempt++ {
            fmt.Printf("--- [Retry] 第 %d/%d 次尝试 ---\n", attempt, maxAttempts)
            if err := stepToRetry.Execute(ctx); err == nil {
                return nil
            } else {
                lastErr = err
                if attempt < maxAttempts {
                    fmt.Printf("    => 失败: %v，%v 后重试...\n", err, delay)
                    time.Sleep(delay)
                }
            }
        }
        return fmt.Errorf("重试 %d 次后仍然失败: %w", maxAttempts, lastErr)
    })
}

// --- 流水线执行器 ---

type Pipeline struct {
    steps []Step
}

func NewPipeline(steps ...Step) *Pipeline {
    return &Pipeline{steps: steps}
}

func (p *Pipeline) Run(ctx *Context) error {
    for _, step := range p.steps {
        err := step.Execute(ctx)
        if err != nil {
            // 使用 reflect 来获取具体步骤的类型名，便于调试
            stepType := reflect.TypeOf(step).String()
            return fmt.Errorf("pipeline failed at step %s: %w", stepType, err)
        }
    }
    return nil
}

// --- 主函数：组装和运行 ---

func main() {
    resourceName := "my-config.yaml"

    // 为了演示场景，我们先保证资源不存在
    delete(worldState, resourceName)

    // 编排流水线
    // 1. 检查资源现状 (Check)
    // 2. 如果存在则更新，如果不存在则创建 (Branch)
    // 3. 使用 WithRetries 包装的 FlakyVerifyStep 做最终验证
    pipeline := NewPipeline(
        &CheckStep{},
        Branch(
            func(ctx *Context) bool { return ctx.Exists },                                        // 条件：资源是否存在？
            func() Step { return NewUpdateStep(map[string]string{"version": "2", "author": "admin"}) }, // True: 更新（工厂）
            func() Step { return NewCreateStep(map[string]string{"version": "1"}) },                    // False: 创建（工厂）
        ),
        WithRetries(3, 1*time.Second, &FlakyVerifyStep{attemptsNeeded: 2}), // 不稳定的验证，最多重试 3 次，每次间隔 1s
    )

    fmt.Println("========= SCENARIO: DEPLOY WITH RETRIES =========")
    ctx := &Context{ResourceName: resourceName}
    if err := pipeline.Run(ctx); err != nil {
        fmt.Printf("\nPipeline failed: %v\n", err)
    } else {
        fmt.Println("\nPipeline finished successfully!")
    }
    fmt.Printf("Final world state: %v\n", worldState)
}
