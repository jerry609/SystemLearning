阶段二，练习2: 声明式流程编排 - BindFunc与Executor

欢迎来到 control 框架的第二个练习！

在练习1中，我们掌握了 Step, Context, Flow 这三个核心概念。然而，真实世界中的协调逻辑远比单个 Step 要复杂。我们可能需要根据某些条件执行不同的 Step，或者将多个 Step 串联起来。这就是流程编排的用武之地。

polardbx-operator 的 control 框架提供了一套优雅的声明式 API 来实现复杂的流程编排，其核心就是 BindFunc 以及 When, Branch 等高阶函数。同时，Executor 则负责解释并执行这些编排好的流程。

练习目标

1.  掌握声明式编排：学会使用 `BindFunc` 将 `Step` 函数绑定，并利用 `When` 和 `Branch` 实现条件判断和分支流程。
2.  理解 Executor：通过构建一个迷你版的 `Executor`，理解它是如何驱动整个声明式流程运行的。
3.  构建复杂工作流：将多个 `Step` 组合成一个有实际意义的、能够根据上下文动态调整行为的工作流。

任务要求

1.  **扩展 `main.go`**：
    在练习1的 main.go 代码基础上继续进行。

2.  引入编排定义：
    - 将 pkg/k8s/control/executor.go 中的 BindFunc 类型定义、When 和 Branch 函数复制到你的 main.go 中。
    - 你可能还需要 step.go 中的 NewStep 函数，它可以将一个 func(ReconcileContext) Flow 转换为一个 Step 对象。

3.  **创建更多的 `Step`**：
    - **`createResourceFunc`**: 模拟创建资源。如果资源已存在，打印信息并返回 `Continue`；如果不存在，在 `mockReconcileContext` 中创建它，打印信息并返回 `Continue`。
    - **`updateResourceFunc`**: 模拟更新资源。如果资源不存在，打印错误并 `Abort`；如果存在，修改它的某个值，打印信息并返回 `Continue`。
    - **`deleteResourceFunc`**: 模拟删除资源。如果资源存在，从 `mockReconcileContext` 中移除它，打印信息并返回 `Continue`；如果不存在，直接返回 `Continue`。

4.  **实现 `MiniExecutor`**：
    - 创建一个 MiniExecutor 结构体。
    - 为它实现一个 Execute 方法，签名为 Execute(ctx ReconcileContext, steps ...Step)。
    - Execute 方法的逻辑是：
        - 遍历传入的 steps。
        - 依次执行每个 Step 的 Execute 方法。
        - 检查每个 Step 返回的 Flow。如果 Flow 表示需要中断（IsAbort()），则立即停止执行后续步骤并返回该 Flow。
        - 如果所有 Step 都成功执行，返回最后一个 Flow。

5.  编排并运行：
    - 在 main 函数中，实例化你的 MiniExecutor。
    - 定义工作流：使用 `When`, `Branch`, `NewStep` 等函数将你的 `check...`, `create...`, `update...` 等 `Step` 编排成一个完整的 “创建或更新” (CreateOrUpdate) 逻辑流。
        - 逻辑：首先检查资源是否存在 (`checkResourceExistsFunc`)。
        - 如果存在 (`When(true, ...)`), 则执行更新操作 (`updateResourceFunc`)。
        - 如果不存在 (`When(false, ...)`), 则执行创建操作 (`createResourceFunc`)。
        - *提示：`Branch` 函数接收一个检查步骤和两个分支步骤，正好适用于此场景。*

    - 运行多个场景：
        - 场景一：资源不存在。初始化一个空的 `mockReconcileContext`，执行编排好的工作流，验证是否执行了创建逻辑。
        - 场景二：资源已存在。初始化一个包含资源的 `mockReconcileContext`，执行工作流，验证是否执行了更新逻辑。

运行与验证

运行 go run main.go，观察不同场景下的输出。你应该能看到 MiniExecutor 根据 Branch 的判断条件，正确地执行了创建或更新的分支，完美地模拟了一个声明式的 CreateOrUpdate 流程。

这个练习将让你深刻体会到声明式编排的强大之处：代码即文档，逻辑清晰，易于组合和测试。

祝你编码愉快！