阶段二，练习1: 核心三剑客 - Step, Context, Flow

你好！从这个练习开始，我们正式进入 polardbx-operator 的核心代码世界。

pkg/k8s/control 包是整个 Operator 的“大脑”，它提供了一个声明式的、可扩展的协调流程框架。理解了它，你就掌握了 polardbx-operator 的脉搏。

我们将从这个框架最核心的三个抽象开始：Step、ReconcileContext 和 Flow。

- **`Step`**: 代表一个原子化的、可重入的协调步骤。它是构成整个协调流程的最小单元。
- **`ReconcileContext`**: 协调过程中的上下文，用于在不同的 `Step` 之间传递信息，例如 K8s 客户端、CRD 对象实例等。
- **`Flow`**: 用于控制 `Step` 的执行流程，例如中断、重试或继续。

练习目标

1.  理解核心抽象：通过动手实现，深入理解 `Step`、`ReconcileContext`、`Flow` 三者如何协同工作。
2.  掌握基本交互：学会如何定义一个 `Step`，并通过 `ReconcileContext` 获取信息，利用 `Flow` 控制流程。
3.  搭建迷你框架：在 `main.go` 中创建一个微型但完整的声明式协调框架的骨架。

任务要求

1.  **创建 `main.go`**：
    在你的 exercise 目录下创建一个新的 main.go 文件。

2.  复制核心抽象：
    将 pkg/k8s/control/step.go 中的 Step 接口、pkg/k8s/control/context.go 中的 ReconcileContext 接口、以及 pkg/k8s/control/flow.go 中的 Flow 接口和相关常量/函数（如 Continue, Abort 等）复制到你的 main.go 中。
    提示：暂时不需要复制完整的实现，只需要接口定义和必要的辅助类型。

3.  实现 Mock 对象：
    - 创建一个 mockReconcileContext 结构体，实现 ReconcileContext 接口。它可以包含一个 map[string]string 来模拟存储在 K8s 中的资源。
    - 创建一个 mockFlow 结构体，实现 Flow 接口。它的方法（Continue, Abort 等）可以简单地打印一条日志，来表明当前流程的状态。

4.  **编写你的第一个 `Step`**：
    - 定义一个名为 checkResourceExistsFunc 的函数，它完全符合 Step 接口的 Execute 方法签名 func(ReconcileContext) Flow。
    - 这个 Step 的逻辑是：
        - 从 ReconcileContext 中读取一个预设的 "resource-name"。
        - 检查这个资源是否存在于 mockReconcileContext 的模拟存储中。
        - 如果存在，打印 "Resource found!" 并返回 flow.Continue("Resource found")。
        - 如果不存在，打印 "Resource not found!" 并返回 flow.Abort("Resource not found")。

5.  组装并运行：
    - 在 main 函数中，创建 mockReconcileContext 和 mockFlow 的实例。
    - 场景一：在 `mockReconcileContext` 中不包含任何资源。
    - 调用 checkResourceExistsFunc，并打印出 Flow 的结果。
    - 场景二：在 `mockReconcileContext` 中包含名为 "my-resource" 的资源。
    - 再次调用 checkResourceExistsFunc，并打印出 Flow 的结果。

运行与验证

当你运行 go run main.go 时，你应该能清晰地看到两种场景下不同的输出，以及 Flow 是如何根据 Step 的执行结果来控制流程的。

这个练习将为你后续理解更复杂的流程编排（如 When, Branch）打下坚实的基础。

祝你好运！