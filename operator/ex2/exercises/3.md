阶段二，练习3: 可观测性与装饰器 -`Trace` 的妙用

你已经掌握了 control 框架的核心抽象和声明式编排，做得非常棒！

现在，我们来探讨一个在任何生产级系统中都至关重要的话题：可观测性 (Observability)。当你的协调流程变得复杂时，如何追踪每一步的执行耗时、输入输出以及最终结果？如果某个 `Step` 失败了，如何快速定位问题？

polardbx-operator 的 `control` 框架通过 `trace.go` 中的 `TracedStep` 给出了一个绝佳的解决方案。它巧妙地运用了装饰器模式 (Decorator Pattern)，在不侵入任何业务逻辑 `Step` 的前提下，为它们注入了日志、监控等横切关注点 (Cross-Cutting Concerns) 的能力。

练习目标

1.  理解装饰器模式：通过 `TracedStep` 的例子，深入理解装饰器模式如何在 Go 中实现，以及它带来的好处（如开闭原则）。
2.  掌握横切关注点处理：学会如何使用 `Trace` 为已有的 `Step` 添加日志和追踪能力，而无需修改 `Step` 自身的代码。
3.  增强 Executor：改造你的 `MiniExecutor`，使其能够自动为所有执行的 `Step` 包裹上 `Trace` 功能。

任务要求

1.  **扩展 `main.go`**：
    继续在练习2的 main.go 代码基础上进行。

2.  **引入 `Trace` 定义**：
    - 将 pkg/k8s/control/trace.go 中的 TracedStep 结构体及其 NewTracedStep 构造函数和 Execute 方法复制到你的 main.go 中。
    - TracedStep 内部包含一个 Step，它的 Execute 方法会在调用内部 Step 的 Execute 前后，打印出日志信息（例如，步骤名称、耗时、Flow 结果等）。

3.  **改造 `MiniExecutor`**：
    - 修改 MiniExecutor 的 Execute 方法。
    - 在执行每个 Step 之前，使用 NewTracedStep 将其包装成一个 TracedStep。
    - 你需要给每个 Step 一个名字。可以考虑修改 NewStep 函数，让它除了接收 Step 函数外，还接收一个 name 字符串。
    - 执行被 Trace 包装后的 Step。

4.  运行并观察输出：
    - 使用与练习2中相同的 “CreateOrUpdate” 逻辑流。
    - 运行你的 main 函数，并仔细观察控制台输出。

运行与验证

当你运行 go run main.go 后，你应该会看到与之前截然不同的输出。对于工作流中的每一步，都会有类似下面这样的日志：

===> EXECUTING STEP: check-resource-existence
     Resource not found!
<=== FINISHED STEP: check-resource-existence (cost: 1.2µs), FLOW: ABORT (Resource not found)

===> EXECUTING STEP: create-resource
     Creating resource: my-resource
<=== FINISHED STEP: create-resource (cost: 0.8µs), FLOW: CONTINUE (Resource created)

你会发现，我们没有修改任何一个业务 Step（如 check..., create...），但它们的执行过程却被完整地追踪和记录下来了。这就是装饰器模式的威力！

这个练习将帮助你理解 polardbx-operator 是如何实现其强大的调试和监控能力的，这也是构建健壮 Operator 的关键一环。

继续前进！