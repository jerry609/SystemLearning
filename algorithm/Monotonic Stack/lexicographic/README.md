# 四、最小字典序专题

## 📖 专题介绍

最小字典序是单调栈的另一个重要应用方向。核心问题是：
- 在满足某些约束条件下，构造字典序最小的序列
- 需要贪心地选择字符/数字
- 使用单调栈维护候选序列

## 💡 核心思想

### 什么是字典序？

字典序（Lexicographical Order）就是字典中单词的排序方式：
- 从左到右逐位比较
- 较小的字符排在前面
- 例如: "abc" < "abd" < "ac"

### 单调栈的作用

在构造最小字典序时，单调栈帮助我们：
1. **维护递增序列**: 尽可能让前面的字符小
2. **延迟决策**: 后面可能有更小的字符
3. **贪心选择**: 在保证合法的前提下选最小的

### 核心策略

```python
栈维护: 当前构造的序列
对于每个新元素 x:
    while 栈顶 > x and 可以删除栈顶:
        弹出栈顶
    if 可以添加 x:
        将 x 入栈
```

## 🎯 题目分类

### 基础题型
- **402. 移掉 K 位数字** (约 1800) - 入门题，删除 K 个数字
- **1673. 找出最具竞争力的子序列** (1802) - 选择 K 个元素

### 去重问题
- **316. 去除重复字母** (2185) - 每个字符只保留一次
- **1081. 不同字符的最小子序列** - 同 316 题

### 复杂约束
- **316 扩展**: 重复个数不超过 limit
- **2030. 含特定字母的最小子序列** (2562) - 必须包含某个字符 k 次

### 合并问题
- **321. 拼接最大数** - 从两个数组中选数字拼接成最大数

详见 `problems.md`

## 📐 算法模板

### 模板1: 删除 K 个元素（402）

```python
def removeKdigits(num: str, k: int) -> str:
    st = []
    for digit in num:
        # 贪心：如果栈顶更大且还能删除，就删除
        while st and k > 0 and st[-1] > digit:
            st.pop()
            k -= 1
        st.append(digit)
    
    # 如果还需要删除（说明序列已经递增）
    if k > 0:
        st = st[:-k]
    
    # 去除前导零
    return ''.join(st).lstrip('0') or '0'
```

### 模板2: 选择 K 个元素（1673）

```python
def mostCompetitive(nums: List[int], k: int) -> List[int]:
    st = []
    n = len(nums)
    for i, x in enumerate(nums):
        # 贪心：如果栈顶更大且后面还有足够的元素，就删除
        while st and st[-1] > x and len(st) + (n - i) > k:
            st.pop()
        if len(st) < k:
            st.append(x)
    return st
```

### 模板3: 去除重复字母（316）

```python
def removeDuplicateLetters(s: str) -> str:
    # 统计每个字符的最后出现位置
    last = {c: i for i, c in enumerate(s)}
    st = []
    in_stack = set()
    
    for i, c in enumerate(s):
        if c in in_stack:
            continue
        
        # 贪心：如果栈顶更大且后面还会出现，就删除
        while st and st[-1] > c and last[st[-1]] > i:
            in_stack.remove(st.pop())
        
        st.append(c)
        in_stack.add(c)
    
    return ''.join(st)
```

## 🎯 关键技巧

### 1. 判断是否可以删除

**删除 K 个数字**（402）:
```python
可以删除 = k > 0  # 还有删除次数
```

**选择 K 个元素**（1673）:
```python
可以删除 = len(st) + (n - i) > k  # 后面还有足够的元素
```

**去除重复字母**（316）:
```python
可以删除 = last[st[-1]] > i  # 后面还会出现
```

### 2. 去除前导零（数字问题）

```python
result = ''.join(st).lstrip('0') or '0'
```

### 3. 使用辅助数据结构

```python
# 记录最后出现位置
last = {c: i for i, c in enumerate(s)}

# 记录是否在栈中
in_stack = set()

# 统计剩余次数
count = Counter(s)
```

## 📊 复杂度分析

- **时间复杂度**: O(n) - 每个元素最多入栈出栈各一次
- **空间复杂度**: O(n) 或 O(字符集大小)

## 💭 常见问题

### Q1: 为什么要用单调栈？
**A**: 因为我们希望构造的序列尽可能递增（对于最小字典序），单调栈天然维护这个性质。

### Q2: 如何避免删多了或删少了？
**A**: 通过条件判断：
- 删除 K 个：检查 `k > 0`
- 选择 K 个：检查 `len(st) + 剩余元素 > k`
- 去重：检查 `后面是否还有`

### Q3: 什么时候该删除栈顶？
**A**: 同时满足三个条件：
1. 栈顶比当前元素大（贪心）
2. 还允许删除（约束条件）
3. 删除后能得到更好的结果

## 🎓 学习路线

1. **402. 移掉 K 位数字** - 理解删除策略
2. **1673. 找出最具竞争力的子序列** - 理解选择策略  
3. **316. 去除重复字母** - 理解去重策略
4. **321. 拼接最大数** - 综合应用
5. **2030. 含特定字母的最小子序列** - 挑战高难度

## 🔗 相关资源

- 回到 [单调栈主页](../README.md)
- 查看 [题目列表](problems.md)
- 回到 [基础部分](../basics/README.md)
