# 三、贡献法专题

## 📖 专题介绍

贡献法是一种重要的算法思想，在单调栈问题中经常使用。核心思路是：
- **不是直接计算总和，而是计算每个元素对答案的贡献**
- 利用单调栈找到每个元素作为最值的范围
- 将问题从 O(n²) 或 O(n³) 优化到 O(n)

## 💡 核心思想

### 什么是贡献法？

传统思路：枚举所有子数组，计算每个子数组的最值
```
时间复杂度：O(n²) 或 O(n³)
```

贡献法思路：枚举每个元素，计算它作为最值时对多少个子数组有贡献
```
时间复杂度：O(n)
```

### 如何计算贡献？

对于元素 `nums[i]`：
1. 使用单调栈找到：
   - `left[i]`: 左侧第一个比它小/大的位置
   - `right[i]`: 右侧第一个比它小/大的位置

2. 则 `nums[i]` 作为最小/最大值的子数组有：
   - 左边界可以是：`left[i]+1` 到 `i`，共 `i-left[i]` 种选择
   - 右边界可以是：`i` 到 `right[i]-1`，共 `right[i]-i` 种选择
   - 总共：`(i-left[i]) × (right[i]-i)` 个子数组

3. 每个子数组中 `nums[i]` 的贡献可能是：
   - `nums[i]` 本身（907 题）
   - `nums[i] × 子数组和`（1856 题）
   - `nums[i] × nums[i] × 子数组和`（2281 题）

## 🎯 题目分类

### 基础贡献法
- **907. 子数组的最小值之和** (1976) - 最经典的贡献法题目
- **2104. 子数组范围和** - 最大值减最小值

### 结合其他技巧
- **1856. 子数组最小乘积的最大值** (2051) - 贡献法 + 前缀和
- **2818. 操作使得分最大** (2397) - 贡献法 + 排序
- **2281. 巫师的总力量和** (2621) - 贡献法 + 前缀和的前缀和

### 高级应用
- **3430. 最多 K 个元素的子数组的最值之和** (2645)
- **3359. 查找最大元素不超过 K 的有序子矩阵**（会员题）

### 思维扩展
- **2334. 元素值大于变化阈值的子数组** (2381)
- **2962. 统计最大元素出现至少 K 次的子数组** - 含思考题

详见 `problems.md`

## 📐 算法模板

### 基础贡献法模板

```python
def sumSubarrayMins(arr: List[int]) -> int:
    MOD = 10**9 + 7
    n = len(arr)
    
    # 找到每个元素左右第一个更小的位置
    left = [-1] * n
    right = [n] * n
    
    # 单调递增栈找左边界
    st = []
    for i in range(n):
        while st and arr[st[-1]] > arr[i]:  # 注意：一侧用 > 一侧用 >=
            st.pop()
        if st:
            left[i] = st[-1]
        st.append(i)
    
    # 单调递增栈找右边界
    st = []
    for i in range(n - 1, -1, -1):
        while st and arr[st[-1]] >= arr[i]:  # 避免重复计数
            st.pop()
        if st:
            right[i] = st[-1]
        st.append(i)
    
    # 计算贡献
    ans = 0
    for i in range(n):
        # nums[i] 作为最小值的子数组个数
        count = (i - left[i]) * (right[i] - i)
        ans = (ans + arr[i] * count) % MOD
    
    return ans
```

### 重要细节

**避免重复计数**：
- 左边界用 `>`，右边界用 `>=`（或相反）
- 这样相等元素不会被重复计算

**处理相等元素**：
```python
# 方法1：左严格，右不严格
while st and arr[st[-1]] > arr[i]:   # 左边
while st and arr[st[-1]] >= arr[i]:  # 右边

# 方法2：左不严格，右严格
while st and arr[st[-1]] >= arr[i]:  # 左边
while st and arr[st[-1]] > arr[i]:   # 右边
```

## 📊 复杂度分析

- **时间复杂度**: O(n) - 单调栈 + 一次遍历计算贡献
- **空间复杂度**: O(n) - 存储左右边界数组

## 💭 解题技巧

### 1. 确定要求什么
- 最小值之和？最大值之和？最大值-最小值？
- 确定是求和还是求最值

### 2. 确定单调性
- 求最小值贡献：单调递增栈
- 求最大值贡献：单调递减栈

### 3. 计算贡献
- 子数组个数：`(i - left[i]) × (right[i] - i)`
- 具体贡献根据题目要求计算

### 4. 结合其他技巧
- **前缀和**: 快速计算子数组和（1856, 2281）
- **前缀和的前缀和**: 计算所有子数组和的和（2281）
- **排序**: 离线处理查询（2818）

## 🎓 学习路线

1. **从 907 开始**: 最经典的贡献法题目，必做
2. **理解重复计数**: 掌握如何避免相等元素的重复计数
3. **加入前缀和**: 1856 题，学习如何结合前缀和
4. **挑战 2281**: 最难的贡献法题目，需要前缀和的前缀和

## 🔗 相关资源

- 回到 [单调栈主页](../README.md)
- 查看 [题目列表](problems.md)
- 继续学习 [最小字典序](../lexicographic/README.md)
