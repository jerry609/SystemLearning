# 订单状态机项目

## 项目背景

本项目实现了一个完整的电商订单状态管理系统，使用状态模式管理订单的生命周期。订单从创建到完成会经历多个状态，每个状态下允许的操作不同。

## 功能列表

- [x] 订单创建和初始化
- [x] 订单支付处理
- [x] 订单发货管理
- [x] 订单确认收货
- [x] 订单取消和退款
- [x] 订单退货处理
- [x] 订单售后服务
- [x] 订单状态历史记录
- [x] 订单状态转换验证
- [x] 订单超时处理

## 技术栈

- Go 1.21+
- 标准库 testing（单元测试）

## 设计模式应用

| 模式 | 应用位置 | 作用 |
|------|----------|------|
| 状态模式 | OrderState 接口及实现 | 管理订单的状态转换和行为 |
| 单例模式 | 状态对象 | 共享无状态的状态对象 |

## 项目结构

```
order-state-machine/
├── README.md           # 项目说明
├── main.go            # 主程序入口和示例
├── state.go           # 状态模式实现
└── state_test.go      # 单元测试
```

## 订单状态流转图

```
待支付 ──支付──> 已支付 ──发货──> 已发货 ──确认收货──> 已完成
  │                │                │                  │
  │                │                │                  │
  └──取消──> 已取消  └──退款──> 退款中  └──退货──> 退货中  └──售后──> 售后中
                                  │                │                │
                                  │                │                │
                                  └──完成──> 已退款  └──完成──> 已退款  └──完成──> 已完成
```

## 状态说明

### 1. 待支付 (Pending)
- **允许操作**: 支付、取消
- **转换目标**: 已支付、已取消

### 2. 已支付 (Paid)
- **允许操作**: 发货、退款
- **转换目标**: 已发货、退款中

### 3. 已发货 (Shipped)
- **允许操作**: 确认收货、退货
- **转换目标**: 已完成、退货中

### 4. 已完成 (Completed)
- **允许操作**: 售后
- **转换目标**: 售后中

### 5. 已取消 (Cancelled)
- **允许操作**: 无
- **转换目标**: 无（终态）

### 6. 退款中 (Refunding)
- **允许操作**: 确认退款
- **转换目标**: 已退款

### 7. 已退款 (Refunded)
- **允许操作**: 无
- **转换目标**: 无（终态）

### 8. 退货中 (Returning)
- **允许操作**: 确认退货
- **转换目标**: 已退款

### 9. 售后中 (AfterSale)
- **允许操作**: 完成售后
- **转换目标**: 已完成

## 运行方式

### 运行主程序

```bash
go run main.go state.go
```

### 运行测试

```bash
go test -v
```

### 运行测试并查看覆盖率

```bash
go test -v -cover
go test -coverprofile=coverage.out
go tool cover -html=coverage.out
```

## 预期输出

```
=== 订单状态机系统 ===

--- 场景1: 正常购买流程 ---
[订单 ORD001] 状态变更: 待支付
[订单 ORD001] 支付成功，金额: 299.99 元
[订单 ORD001] 状态变更: 已支付
[订单 ORD001] 开始发货
[订单 ORD001] 状态变更: 已发货
[订单 ORD001] 确认收货
[订单 ORD001] 状态变更: 已完成

订单状态历史:
  [2024-01-15 10:00:00] 状态变更: 待支付 -> 已支付
  [2024-01-15 10:00:01] 状态变更: 已支付 -> 已发货
  [2024-01-15 10:00:02] 状态变更: 已发货 -> 已完成

--- 场景2: 支付前取消 ---
[订单 ORD002] 状态变更: 待支付
[订单 ORD002] 取消订单
[订单 ORD002] 状态变更: 已取消

...
```

## 核心代码说明

### 状态接口定义

```go
type OrderState interface {
    Pay(order *Order) error
    Ship(order *Order) error
    Confirm(order *Order) error
    Cancel(order *Order) error
    String() string
}
```

### 订单类

```go
type Order struct {
    ID      string
    Amount  float64
    state   OrderState
    history []string
}
```

### 状态转换

每个状态类实现 OrderState 接口，根据当前状态决定是否允许某个操作，并在操作成功后转换到新状态。

## 扩展建议

1. **订单超时处理**: 添加定时器，自动取消超时未支付的订单
2. **订单通知**: 在状态变更时发送通知（邮件、短信）
3. **订单查询**: 实现订单查询和筛选功能
4. **订单统计**: 统计各状态的订单数量和金额
5. **并发处理**: 添加锁机制，支持并发操作
6. **持久化**: 将订单状态保存到数据库
7. **事件驱动**: 使用事件驱动架构，解耦状态变更和业务逻辑
8. **状态机可视化**: 生成状态转换图

## 学习要点

1. **状态模式的应用**: 理解如何使用状态模式管理复杂的状态转换
2. **状态封装**: 每个状态类封装了该状态下的行为
3. **开闭原则**: 添加新状态不需要修改现有代码
4. **状态转换控制**: 状态转换由状态对象自己控制
5. **历史记录**: 维护状态变更历史，便于追踪和审计

## 常见问题

### Q1: 如何添加新的状态？

创建新的状态类实现 OrderState 接口，并在相关状态中添加转换逻辑。

### Q2: 如何处理非法的状态转换？

在每个状态的操作方法中检查是否允许该操作，不允许则返回错误。

### Q3: 如何实现状态的持久化？

可以在状态转换时将订单信息保存到数据库，恢复时根据保存的状态创建对应的状态对象。

### Q4: 如何处理并发操作？

可以使用互斥锁（sync.Mutex）保护订单的状态转换操作。

## 参考资源

- 状态模式理论: `../../theory/01-state.md`
- 订单状态示例: `../../examples/state/order_state.go`
