# 设计模式系统学习

## 📚 课程概述

本课程系统讲解 23 种经典设计模式，通过理论讲解、代码实现和实战项目，帮助你掌握面向对象设计的核心思想。

## 🎯 学习目标

- 理解设计模式的六大原则（SOLID + 迪米特法则 + 开闭原则）
- 掌握 23 种 GoF 设计模式的应用场景
- 能够在实际项目中灵活运用设计模式
- 提升代码的可维护性、可扩展性和可复用性

## 📖 课程大纲

### 创建型模式 (Creational Patterns)

#### Lab 01: 单例模式与工厂模式
- **单例模式 (Singleton)**
  - 饿汉式、懒汉式、双重检查锁
  - Go 语言的 sync.Once 实现
  - 应用场景：配置管理、数据库连接池
- **工厂模式 (Factory)**
  - 简单工厂、工厂方法、抽象工厂
  - 应用场景：对象创建解耦
- **实战项目**：实现一个配置管理器和日志工厂

#### Lab 02: 建造者模式与原型模式
- **建造者模式 (Builder)**
  - 链式调用、流式接口
  - Go 语言的 Functional Options 模式
  - 应用场景：复杂对象构建
- **原型模式 (Prototype)**
  - 深拷贝与浅拷贝
  - Go 语言的实现方式
  - 应用场景：对象克隆
- **实战项目**：实现一个 HTTP 请求构建器

### 结构型模式 (Structural Patterns)

#### Lab 03: 适配器模式与装饰器模式
- **适配器模式 (Adapter)**
  - 类适配器、对象适配器
  - 接口转换
  - 应用场景：第三方库集成
- **装饰器模式 (Decorator)**
  - 动态添加功能
  - Go 语言的中间件实现
  - 应用场景：日志、缓存、权限控制
- **实战项目**：实现一个 HTTP 中间件系统

#### Lab 04: 代理模式与外观模式
- **代理模式 (Proxy)**
  - 静态代理、动态代理
  - 远程代理、虚拟代理、保护代理
  - 应用场景：RPC、缓存、权限控制
- **外观模式 (Facade)**
  - 简化复杂系统接口
  - 应用场景：子系统封装
- **实战项目**：实现一个缓存代理和 API 外观

#### Lab 05: 组合模式与享元模式
- **组合模式 (Composite)**
  - 树形结构处理
  - 应用场景：文件系统、组织架构
- **享元模式 (Flyweight)**
  - 对象池、共享对象
  - 应用场景：大量细粒度对象
- **实战项目**：实现一个文件系统和对象池

#### Lab 06: 桥接模式
- **桥接模式 (Bridge)**
  - 抽象与实现分离
  - 应用场景：跨平台开发、多维度变化
- **实战项目**：实现一个跨平台消息发送系统

### 行为型模式 (Behavioral Patterns)

#### Lab 07: 策略模式与观察者模式
- **策略模式 (Strategy)**
  - 算法族封装
  - Go 语言的函数式实现
  - 应用场景：支付方式、排序算法
- **观察者模式 (Observer)**
  - 发布-订阅模式
  - Go 语言的 channel 实现
  - 应用场景：事件系统、消息队列
- **实战项目**：实现一个事件总线系统

#### Lab 08: 命令模式与责任链模式
- **命令模式 (Command)**
  - 请求封装、撤销重做
  - 应用场景：任务队列、宏命令
- **责任链模式 (Chain of Responsibility)**
  - 请求处理链
  - 应用场景：中间件、审批流程
- **实战项目**：实现一个任务调度系统

#### Lab 09: 状态模式与模板方法模式
- **状态模式 (State)**
  - 状态机实现
  - 应用场景：订单状态、游戏状态
- **模板方法模式 (Template Method)**
  - 算法骨架定义
  - 应用场景：框架设计
- **实战项目**：实现一个订单状态机

#### Lab 10: 迭代器模式与访问者模式
- **迭代器模式 (Iterator)**
  - 遍历聚合对象
  - Go 语言的 range 实现
  - 应用场景：集合遍历
- **访问者模式 (Visitor)**
  - 操作与数据结构分离
  - 应用场景：AST 遍历、编译器
- **备忘录模式 (Memento)**
  - 状态保存与恢复
  - 应用场景：撤销重做、快照
- **中介者模式 (Mediator)**
  - 对象间通信解耦
  - 应用场景：聊天室、MVC
- **解释器模式 (Interpreter)**
  - 语言解释器
  - 应用场景：表达式求值、DSL
- **实战项目**：实现一个表达式解释器

#### Lab 11: 综合实战 - 设计模式组合应用
- **项目 1**：实现一个微服务框架
  - 使用工厂模式创建服务
  - 使用装饰器模式实现中间件
  - 使用观察者模式实现事件系统
  - 使用策略模式实现负载均衡
- **项目 2**：实现一个 ORM 框架
  - 使用建造者模式构建查询
  - 使用代理模式实现懒加载
  - 使用模板方法模式定义 CRUD 流程
- **项目 3**：实现一个游戏引擎
  - 使用组合模式管理游戏对象
  - 使用状态模式管理游戏状态
  - 使用命令模式实现操作记录
  - 使用观察者模式实现事件系统

## 🗂️ 目录结构

```
design-patterns/
├── README.md                                    # 本文件
├── lab01-创建型模式-单例与工厂/
│   ├── README.md                               # Lab 说明
│   ├── theory/                                 # 理论讲解
│   │   ├── singleton.md                        # 单例模式
│   │   └── factory.md                          # 工厂模式
│   ├── examples/                               # 示例代码
│   │   ├── singleton/
│   │   └── factory/
│   ├── exercises/                              # 练习题
│   │   ├── exercise1.md
│   │   └── exercise2.md
│   └── project/                                # 实战项目
│       └── config-manager/
├── lab02-创建型模式-建造者与原型/
├── lab03-结构型模式-适配器与装饰器/
├── lab04-结构型模式-代理与外观/
├── lab05-结构型模式-组合与享元/
├── lab06-结构型模式-桥接模式/
├── lab07-行为型模式-策略与观察者/
├── lab08-行为型模式-命令与责任链/
├── lab09-行为型模式-状态与模板方法/
├── lab10-行为型模式-迭代器与访问者/
└── lab11-综合实战-设计模式组合应用/
```

## 🚀 快速开始

### 前置要求

- Go 1.21+ 或 Java 11+ 或 Python 3.8+
- 基础的面向对象编程知识
- 了解接口、继承、多态等概念

### 学习路径

**初学者路径** (30-40 小时)
1. 学习设计原则（SOLID）
2. 完成 Lab 01-05（创建型和结构型模式）
3. 完成每个 Lab 的练习题
4. 完成 2-3 个实战项目

**进阶路径** (50-60 小时)
1. 完成所有 11 个 Lab
2. 完成所有练习题和实战项目
3. 阅读开源项目中的设计模式应用
4. 重构自己的项目代码

**专家路径** (80+ 小时)
1. 完成进阶路径
2. 研究设计模式的变体和组合
3. 分析框架源码中的设计模式
4. 撰写设计模式博客或教程
5. 参与开源项目，应用设计模式

### 学习建议

1. **理论与实践结合**：每学习一个模式，立即编写代码实现
2. **对比分析**：对比不同模式的适用场景和优缺点
3. **重构练习**：找一段代码，尝试用设计模式重构
4. **阅读源码**：分析知名框架中的设计模式应用
5. **记录笔记**：记录每个模式的使用场景和注意事项

## 📊 学习进度跟踪

| Lab | 模式 | 状态 | 完成时间 | 笔记 |
|-----|------|------|----------|------|
| 01 | 单例、工厂 | ⬜ 未开始 | - | - |
| 02 | 建造者、原型 | ⬜ 未开始 | - | - |
| 03 | 适配器、装饰器 | ⬜ 未开始 | - | - |
| 04 | 代理、外观 | ⬜ 未开始 | - | - |
| 05 | 组合、享元 | ⬜ 未开始 | - | - |
| 06 | 桥接 | ⬜ 未开始 | - | - |
| 07 | 策略、观察者 | ⬜ 未开始 | - | - |
| 08 | 命令、责任链 | ⬜ 未开始 | - | - |
| 09 | 状态、模板方法 | ⬜ 未开始 | - | - |
| 10 | 迭代器、访问者等 | ⬜ 未开始 | - | - |
| 11 | 综合实战 | ⬜ 未开始 | - | - |

## 🎓 设计原则

在学习设计模式之前，先理解这些设计原则：

### SOLID 原则

1. **单一职责原则 (SRP)**
   - 一个类只负责一个功能领域
   - 降低类的复杂度，提高可读性

2. **开闭原则 (OCP)**
   - 对扩展开放，对修改关闭
   - 通过抽象实现稳定性

3. **里氏替换原则 (LSP)**
   - 子类可以替换父类
   - 保证继承的正确性

4. **接口隔离原则 (ISP)**
   - 客户端不应依赖不需要的接口
   - 接口应该小而专一

5. **依赖倒置原则 (DIP)**
   - 依赖抽象而非具体实现
   - 高层模块不依赖低层模块

### 其他原则

6. **迪米特法则 (LoD)**
   - 最少知识原则
   - 降低类之间的耦合

7. **合成复用原则 (CRP)**
   - 优先使用组合而非继承
   - 提高灵活性

## 📚 推荐资源

### 书籍
- 《设计模式：可复用面向对象软件的基础》（GoF）
- 《Head First 设计模式》
- 《重构：改善既有代码的设计》
- 《代码整洁之道》

### 在线资源
- [Refactoring.Guru](https://refactoring.guru/design-patterns)
- [SourceMaking](https://sourcemaking.com/design_patterns)
- [Design Patterns in Go](https://github.com/tmrts/go-patterns)

### 开源项目
- Spring Framework (Java)
- Gin Web Framework (Go)
- Django (Python)
- React (JavaScript)

## 💡 常见问题

### Q1: 设计模式是银弹吗？
不是。设计模式是解决特定问题的方案，过度使用会导致代码复杂化。

### Q2: 什么时候使用设计模式？
当你遇到重复的设计问题，且该模式能简化解决方案时。

### Q3: 如何选择合适的设计模式？
1. 分析问题的本质
2. 确定变化点
3. 选择能够封装变化的模式

### Q4: Go 语言如何实现设计模式？
Go 语言没有类和继承，但可以通过接口、组合和函数实现大部分模式。

## 🎯 学习目标检查

完成本课程后，你应该能够：

- [ ] 说出 23 种设计模式的名称和分类
- [ ] 解释每种模式的意图和适用场景
- [ ] 用代码实现每种模式
- [ ] 识别开源项目中的设计模式
- [ ] 在实际项目中应用设计模式
- [ ] 重构代码以应用设计模式
- [ ] 评估设计模式的优缺点
- [ ] 组合使用多种设计模式

## 📞 获取帮助

- 查看每个 Lab 的 README.md
- 参考 examples/ 目录的示例代码
- 查看 exercises/ 目录的练习答案
- 阅读推荐的书籍和在线资源

---

**开始学习**: 从 [Lab 01](./lab01-创建型模式-单例与工厂/README.md) 开始你的设计模式之旅！

**祝学习愉快！** 🎉
