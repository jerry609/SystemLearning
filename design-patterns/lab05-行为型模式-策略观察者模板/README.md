# Lab 05: 行为型模式 - 策略、观察者、模板方法

> ⭐⭐⭐ **最重要的行为型模式学习单元**
> 
> 本 Lab 涵盖三种最常用的行为型设计模式，它们是构建灵活、可扩展系统的核心技术。

## 📚 学习目标

- 掌握策略模式，学会封装算法族并实现运行时切换
- 理解观察者模式，掌握发布-订阅和事件驱动架构
- 学习模板方法模式，掌握算法骨架的定义和钩子方法的使用
- 能够在实际项目中灵活运用这三种模式
- 理解这三种模式在 Go 语言中的惯用实现方式

## 📖 内容概览

### 1. 策略模式 (Strategy Pattern)

**定义**: 定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。策略模式让算法的变化独立于使用算法的客户。

**应用场景**:
- 支付方式选择（支付宝、微信、银行卡）
- 排序算法选择（快速排序、归并排序、冒泡排序）
- 路由策略选择（最短路径、最快路径、避开拥堵）
- 压缩算法选择（ZIP、RAR、7Z）

**实现方式**:
- 定义策略接口
- 实现具体策略
- 上下文持有策略引用
- 运行时动态切换策略

### 2. 观察者模式 (Observer Pattern)

**定义**: 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**应用场景**:
- 事件总线系统
- 发布-订阅消息系统
- GUI 事件处理
- 数据变化监听
- 日志系统

**实现方式**:
- 定义主题（Subject）接口
- 定义观察者（Observer）接口
- 主题维护观察者列表
- 状态变化时通知所有观察者

### 3. 模板方法模式 (Template Method Pattern)

**定义**: 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些特定步骤。

**应用场景**:
- 框架设计（生命周期钩子）
- 工作流引擎
- 数据处理流程
- 测试框架
- HTTP 请求处理流程

**实现方式**:
- 定义抽象模板接口
- 实现模板方法（算法骨架）
- 定义抽象步骤和钩子方法
- 具体实现覆盖抽象步骤

## 🗂️ 目录结构

```
lab05-行为型模式-策略观察者模板/
├── README.md                           # 本文件
├── theory/                             # 理论文档
│   ├── 01-strategy.md                 # 策略模式理论
│   ├── 02-observer.md                 # 观察者模式理论
│   └── 03-template.md                 # 模板方法模式理论
├── examples/                           # 示例代码
│   ├── strategy/                      # 策略模式示例
│   │   ├── payment_strategy.go       # 支付策略示例
│   │   ├── sort_strategy.go          # 排序策略示例
│   │   └── route_strategy.go         # 路由策略示例
│   ├── observer/                      # 观察者模式示例
│   │   ├── event_bus.go              # 事件总线示例
│   │   └── pub_sub.go                # 发布-订阅示例
│   └── template/                      # 模板方法模式示例
│       ├── framework_template.go     # 框架模板示例
│       └── workflow_template.go      # 工作流模板示例
├── exercises/                          # 练习题
│   ├── exercise1.md                   # 练习 1: 策略模式
│   ├── exercise2.md                   # 练习 2: 观察者模式
│   ├── exercise3.md                   # 练习 3: 模板方法模式
│   └── answers/                       # 参考答案
│       ├── exercise1_answer.go
│       ├── exercise2_answer.go
│       └── exercise3_answer.go
└── project/                            # 实战项目
    └── event-bus-system/              # 事件总线系统
        ├── README.md
        ├── main.go
        ├── eventbus.go
        └── eventbus_test.go
```

## 🚀 快速开始

### 1. 学习理论

按顺序阅读理论文档：
```bash
# 策略模式
cat theory/01-strategy.md

# 观察者模式
cat theory/02-observer.md

# 模板方法模式
cat theory/03-template.md
```

### 2. 运行示例

```bash
# 策略模式示例
cd examples/strategy
go run payment_strategy.go
go run sort_strategy.go
go run route_strategy.go

# 观察者模式示例
cd examples/observer
go run event_bus.go
go run pub_sub.go

# 模板方法模式示例
cd examples/template
go run framework_template.go
go run workflow_template.go
```

### 3. 完成练习

阅读练习题并尝试实现：
```bash
# 查看练习题
cat exercises/exercise1.md
cat exercises/exercise2.md
cat exercises/exercise3.md

# 完成后对比参考答案
cat exercises/answers/exercise1_answer.go
```

### 4. 实战项目

```bash
cd project/event-bus-system
go run main.go
go test -v
```

## 📝 学习路径

### 初学者路径 (6-8 小时)

1. **理论学习** (2 小时)
   - 阅读三个模式的理论文档
   - 理解每个模式的定义、意图和适用场景
   - 对比三个模式的异同

2. **示例学习** (2 小时)
   - 运行所有示例代码
   - 理解每个示例的实现细节
   - 修改示例代码，观察运行结果

3. **练习实践** (2 小时)
   - 完成三个练习题
   - 对比参考答案
   - 总结实现要点

4. **项目实战** (2 小时)
   - 研究事件总线系统项目
   - 理解模式的综合应用
   - 尝试扩展项目功能

### 进阶路径 (4-6 小时)

1. **深入理论** (1 小时)
   - 研究模式的变体和扩展
   - 理解模式组合使用
   - 学习 Go 语言特有实现

2. **高级示例** (1 小时)
   - 分析示例代码的设计决策
   - 思考性能和可扩展性
   - 探索其他实现方式

3. **挑战练习** (1 小时)
   - 完成练习题的扩展挑战
   - 优化代码性能
   - 添加新功能

4. **项目深化** (2 小时)
   - 扩展事件总线系统
   - 添加持久化功能
   - 实现分布式事件总线

## 💡 关键概念

### 策略模式核心

- **算法族**: 一组可互换的算法
- **封装变化**: 将变化的部分封装成独立的策略
- **运行时切换**: 在运行时动态选择策略
- **开闭原则**: 对扩展开放，对修改关闭

### 观察者模式核心

- **一对多依赖**: 一个主题对应多个观察者
- **自动通知**: 状态变化时自动通知观察者
- **松耦合**: 主题和观察者之间松耦合
- **事件驱动**: 基于事件的异步通信

### 模板方法模式核心

- **算法骨架**: 定义算法的整体结构
- **延迟实现**: 某些步骤延迟到子类实现
- **钩子方法**: 提供可选的扩展点
- **控制反转**: 框架调用应用代码

## 🎯 练习题预览

### 练习 1: 文件压缩策略系统 (策略模式)
实现一个文件压缩系统，支持多种压缩算法（ZIP、GZIP、BZIP2），用户可以根据需要选择不同的压缩策略。

**难度**: ⭐⭐  
**预计时间**: 40 分钟

### 练习 2: 股票价格监控系统 (观察者模式)
实现一个股票价格监控系统，当股票价格变化时，自动通知所有订阅者（邮件通知、短信通知、App 推送）。

**难度**: ⭐⭐  
**预计时间**: 45 分钟

### 练习 3: 数据导入框架 (模板方法模式)
实现一个数据导入框架，定义导入流程的骨架（验证、转换、保存），支持不同格式的数据导入（CSV、JSON、XML）。

**难度**: ⭐⭐  
**预计时间**: 50 分钟

## 📊 学习检查清单

### 策略模式
- [ ] 理解策略模式的定义和意图
- [ ] 掌握策略接口的设计
- [ ] 能够实现具体策略类
- [ ] 理解上下文类的作用
- [ ] 能够在运行时切换策略
- [ ] 了解策略模式的优缺点
- [ ] 能够识别适合使用策略模式的场景

### 观察者模式
- [ ] 理解观察者模式的定义和意图
- [ ] 掌握主题和观察者接口的设计
- [ ] 能够实现观察者的注册和注销
- [ ] 理解通知机制的实现
- [ ] 了解推模型和拉模型的区别
- [ ] 能够处理观察者的异常情况
- [ ] 理解观察者模式与发布-订阅的区别

### 模板方法模式
- [ ] 理解模板方法模式的定义和意图
- [ ] 掌握模板方法的设计
- [ ] 能够定义抽象步骤和钩子方法
- [ ] 理解控制反转的概念
- [ ] 能够在 Go 中实现模板方法模式
- [ ] 了解模板方法模式的优缺点
- [ ] 能够识别适合使用模板方法模式的场景

### 综合应用
- [ ] 能够对比三种模式的异同
- [ ] 理解三种模式的组合使用
- [ ] 能够在实际项目中选择合适的模式
- [ ] 掌握 Go 语言中的惯用实现方式

## 🔗 相关资源

### 推荐阅读
- 《设计模式：可复用面向对象软件的基础》- GoF
- 《Head First 设计模式》- Freeman
- 《Go 语言设计模式》- Mario Castro Contreras

### 开源项目示例

**策略模式**:
- Kubernetes Scheduler: 多种调度策略
- Go 标准库 sort 包: 自定义排序策略

**观察者模式**:
- Go 标准库 context 包: 取消信号传播
- NATS: 发布-订阅消息系统
- EventBus: Go 事件总线库

**模板方法模式**:
- Go 标准库 http.Handler: HTTP 请求处理模板
- Gin 框架: 中间件链和生命周期钩子
- GORM: 数据库操作钩子

## 📞 常见问题

### Q1: 策略模式和状态模式有什么区别？
A1: 策略模式关注算法的替换，客户端主动选择策略；状态模式关注状态的转换，状态转换通常由对象内部控制。策略模式中的策略是平等的，而状态模式中的状态有转换关系。

### Q2: 观察者模式和发布-订阅模式有什么区别？
A2: 观察者模式中，主题直接维护观察者列表并通知；发布-订阅模式中，发布者和订阅者通过消息中间件解耦，彼此不知道对方的存在。发布-订阅模式更加松耦合。

### Q3: Go 语言如何实现模板方法模式？
A3: Go 语言没有继承，可以使用接口和组合来实现。定义一个包含模板方法的结构体，通过接口参数接收具体实现，或者使用函数类型作为参数实现钩子方法。

### Q4: 什么时候应该使用策略模式？
A4: 当你有多个相似的算法，并且需要在运行时动态选择时；当你想避免使用大量的条件语句（if-else 或 switch）时；当算法的变化独立于使用它的客户端时。

### Q5: 观察者模式如何避免内存泄漏？
A5: 确保观察者在不再需要时及时注销；使用弱引用（Go 中可以使用 context 实现）；定期清理无效的观察者；在观察者的生命周期结束时自动注销。

### Q6: 模板方法模式的钩子方法有什么作用？
A6: 钩子方法提供了可选的扩展点，子类可以选择性地覆盖钩子方法来改变算法的某些行为，而不影响算法的整体结构。钩子方法通常有默认实现（可以是空实现）。

## 🎓 下一步

完成本 Lab 后，你将掌握三种最重要的行为型设计模式。接下来可以：

1. **继续学习**: 进入 [Lab 06: 状态、命令、责任链模式](../lab06-行为型模式-状态命令责任链/README.md)
2. **深入实践**: 在实际项目中应用这些模式
3. **模式组合**: 学习如何组合使用多种模式
4. **性能优化**: 研究模式实现的性能优化技巧

---

**学习建议**: 行为型模式关注对象之间的通信和职责分配，理解这些模式的关键是理解它们如何让对象之间的协作更加灵活。建议通过实际项目来加深理解，而不仅仅是记住模式的结构。

**实践提示**: 在学习过程中，尝试思考你之前写过的代码中哪些地方可以使用这些模式来改进。设计模式不是为了使用而使用，而是为了解决实际问题。
